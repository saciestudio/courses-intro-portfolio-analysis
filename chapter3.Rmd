---
title       : Performance drivers
description : In addition to studying portfolio performance based on the observed portfolio return series, it is relevant to find out how individual (expected) returns, volatilities and correlations interact to determine the total portfolio performance. 

--- type:VideoExercise lang:r xp:50 skills:1  key:bf1fc7dc803e342b4475c296bbebc2bab9b26f32
## The drivers in case of two assets

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v6/hls-ch3_1.master.m3u8

--- type:MultipleChoiceExercise lang:r xp:50 skills:1   key:27fc122215
## Driver 1: The assets' individual performance

So far in the previous chapters you have seen that there are three types of drivers for a portfolio's performance: (i) the individual performance of the assets in terms of risk and return, (ii) the portfolio weight of each of the assets, (iii) the correlation between the asset returns. 
  
You will now explore how the portfolio mean return and volatility depends on the mean returns and volatility of the assets that a portfolio is invested in. In this example you will consider investing—with monthly frequency—in US equities and US bonds. Each asset's returns are stored in your workspace as  `returns_equities`, and `returns_bonds`, in addition the portfolio returns are stored as `returns_6040`. You have a portfolio that is invested 60/40, meaning that every month you invest 60% in equities, and 40% bonds.

Which of the following statements about the relationship between portfolio performance (investing in both equities and bonds) and the individual assets' performance (investing in only one of them) is false. 

*** =instructions
- Investing entirely in `returns_equities` has a lower risk than investing in the portfolio. 
`all.equal(0.6*sd(returns_equities)+0.4*sd(returns_bonds), sd(returns_equities)).
- The portfolio mean return equals the position weighted sum of the component mean returns. This is written as: `all.equal(mean(returns_6040), 0.6 * mean(returns_equities) + 0.4 * mean(returns_bonds))`.
- Investing `returns_bonds` has a lower risk and thus a higher reward!
- None of the above statements are correct.

*** =hint
The proof is in the pudding. Use the code in the instructions in the console and you will find the solution to the problem.

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])

### plot
weights <- c(0.6,0.4)
prices <- cbind(eq_prices,bond_prices)
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_6040 <- Return.portfolio(returns, weights,rebalance_on="months")
# check: all.equal( as.numeric(returns_6040),as.numeric(0.6*returns[,1]+0.4*returns[,2])  )
prices_6040 <- zoo(cumprod(1+returns_6040),order.by=time(returns_6040))
temp <- c( as.numeric(eq_prices), as.numeric(bond_prices) )
ylim <- c( min( temp ) , max(temp) )
plot.zoo(eq_prices , main="Equity-bond portfolios",ylab="", xlab="",ylim=ylim)
lines(bond_prices,col="red")
lines(prices_6040,col="blue")
legend("topleft", legend=c("Equities (ticker: SPY)","Bonds (ticker: AGG)","60/40 Equities-Bonds") , col=c("black","red","blue") , lwd = 1 )

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
```

*** =sct
```{r}
msg1 <- "Risk is measured by the volatility (standard-deviation)!"
msg2 <- "Good job!"
msg3 <- "Bonds have a low risk, and limited reward."
msg4 <- "Try running some of the code we provided!"
test_mc(2, feedback_msgs = c(msg1, msg2, msg3, msg4)) 
success_msg("Good job!")
```

--- type:NormalExercise lang:r xp:50 skills:1     key:69c5664fdb
## Driver 2: the choice of porfolio weights

Investors can optimize the choice of weight to obtain the highest risk-adjusted return, as measured by the portfolio Sharpe ratio.

In the special case of investing the total portfolio value in only two assets, there is only one weight to determine, since the weight on the second asset equals one minus the weight of the first asset. 

Let us do this in the case of a portfolio invested US equities and US bonds. We will be using the brute force approach of trying a large number of possible weights and keeping the weight that yields the highest value for hte portfolio Sharpe ratio.   



*** =instructions
- Complete the R script that runs a brute force search to determine the portfolio weights for which the Sharpe ratio is the highest, assuming a zero risk free rate. 
- Plot the value of the Sharpe ratio as a function of the equity weight in the portfolio, and indicate with a verticle line the value of the equities weight that maximizes the portfolio Sharpe ratio. 

*** =hint
hint

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
```

*** =sample_code
```{r}
# returns_equities and returns_bonds are preloaded

# grid defining possible weights equities 
grid <- seq(0,1,0.01)
print(grid);
# initialize vector in which the Sharpe ratios will be saved
vsharpe <- rep(NA,length(grid))
# initialize counter
i <- 1
#loop over the elements in the search grid
for(w in grid){
  # portfolio returns are monthly rebalanced
  preturns <- w*returns_equities+(1-w)*returns_bonds
  # compute the shapre ratio of preturns
  vsharpe[i] <- 
  # update counter  
  i <- 
}

# plot the obtained Sharpe ratios against the equity weights
plot(  ,   ,xlab="Equity weights",ylab="Ann. Sharpe ratio")
abline(v=grid[vsharpe==max(vsharpe)],lty=3)
```


*** =solution
```{r}
# PerformaneAnalytics is pre-loaded
# returns_equities and returns_bonds are preloaded
grid <- seq(0,1,0.01)
vsharpe <- rep(NA,length(grid))
i <- 1
for(w in grid){
  preturns <- w*returns_equities+(1-w)*returns_bonds
  vsharpe[i] <- SharpeRatio.annualized(preturns)
  #vsharpe[i] <- SharpeRatio.annualized(preturns)
  i <- i+1
}
plot(grid,vsharpe,xlab="weights",ylab="Ann. Sharpe ratio")
abline(v=grid[vsharpe==max(vsharpe)],lty=3)
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:MultipleChoiceExercise lang:r xp:50 skills:1     key:f4f41f6b81
## Driver 3: The correlation between the asset returns

The third driver of portfolio performance is the correlation between the asset returns. Generally speaking, the correlation tells you how two asset returns tend to move together.

The correlation of assets has important consequences in overall portfolio performance. This correlation is important because it can reduce volatility through diversification, or reducing overall correlation. In fact, the lower the correlation, the more succesful the portfolio tends to be in regards to partially offsetting large losses in one asset with only a minor loss, or even a gain in another asset. 

In the extreme case of two identical asset returns, the correlation will be 1, and there is no diversification potential. In the other extreme case where, if one asset return is above average, and the other is almost always below average, the correlation is negative. The correlation is 0 when the asset returns are independent of eachother.

As an exercise, suppose you have an equally weighted portfolio of two assets. Their correlation jumps from 0 to 0.5. Then the portfolio variance:    

*** =instructions
- Decreases
- Increases
- Does not change  

*** =hint
Remember from the video that the portfolio variance equals the squared weight of asset 1 times the variance of asset 1, plus the squared weight of asset 2 times the variance of asset 2, plus two times the product of the weights, the volatilities and their correlation. 

*** =pre_exercise_code
```{r}

```


*** =sct
```{r}
# sct code
test_mc(2) 
success_msg("Great work!")
```



--- type:NormalExercise lang:r xp:100 skills:1 key:b6a986b0e53bd119933fc39df94f21f2bf1e4318
## Interpreting correlation

Now you will learn how to compute the correlation between equity returns and bond returns. Just like volatilities, these correlations are dynamic. Therefore you need to distinguish between a static analysis that calculates correlations over a complete samples, and a dynamic analysis that calculates correlations over a rolling sample. This is a similar analysis as you did for the time-varying performance evaluation in terms of mean return and volatility. 

In this exercise you will learn 3 new functions from the PerformanceAnalytics package. These are `chart.Scatter`, `chart.Correlation`, and `chart.RollingCorrelation`. 

*** =instructions
- Plot the equity returns (`returns_equities`) against the bond returns (`returns_bonds`) using the function [`chart.Scatter`](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/chart.Scatter) with the bond returns on the x-asis. Do you see a relation? 
- Compute the correlation between the variables `returns_equities` and `returns_bonds` using the standard function `cor()`.
- Merge `return_equities`, and `returns_bonds`. Call this `returns`.
- Compute and visualize the correlation again, except using `chart.Correlation` with `returns` as the argument. 
- Commpute the rolling 24-month estimates of the bond-equity correlation using the function `chart.RollingCorrelation`, use the arguments `"R"`, and `"width"`. 

*** =hint
`chart.RollingCorrelation` uses two time-series for the argument `"R"`, and the `"width"` is the number of months

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
```

*** =sample_code
```{r}
# Create a scatter plot


# Find the correlation


# Merge returns_equities and returns_bonds 


# Find and visualize the correlation using chart.Correlation


# Visualize the rolling estimates using chart.RollingCorrelation
chart.RollingCorrelation(___, ___, width = ___)


```

*** =solution
```{r}
# Create a scatter plot
chart.Scatter(returns_equities,  returns_bonds)

# Find the correlation
cor(returns_equities, returns_bonds)

# Merge returns_equities and returns_bonds 
returns <- merge(returns_equities,returns_bonds)

# Find and visualize the correlation using chart.Correlation
chart.Correlation(returns)

# Visualize the rolling estimates using chart.RollingCorrelation
chart.RollingCorrelation(returns_equities, returns_bonds, width = 24)
```

*** =sct
```{r}
# sct code
#1st
test_function("chart.Scatter", c("x", "y"))

#2nd
test_function("cor", c("x", "y"))

#3rd
test_object("returns")

#4th
test_function("chart.Correlation", c("R"))

#5th
test_function("chart.RollingCorrelation", c("Ra", "Rb", "width"))
success_msg("Well done!")
```


--- type:VideoExercise lang:r xp:50 skills:1 key:a2866e000af4e20577dc0d48d46765e2da1a7d9b
## The general case using matrix notation

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v2/hls-ch3_2.master.m3u8

--- type:NormalExercise lang:r xp:100 skills:1 key:080c6863fc
## Making a risk-reward scatter diagram

Investors know that each asset that they invest in has risk, and that each asset performs differently. That's why you will not only invest in US equities and US bonds, but you will *diversify* your portfolio by investing in real estate, commoditites, among others! 

In this example you have decided to extend your investment opportunity by creating a portfolio that consists of US equities ETF (SPY), US bonds ETF (AGG), a real estate investment trust (VEIEX), and an ETF tracking in the GSCI commodities index (GSG). The plot in the environment displays the performance of these investments.

A good way to visualize the relative attractivenss of investments in terms of risk and rewards is to make a scatter 
plot of the average returns against the portfolio volatilities. 

We need to compute those average returns and volatilities for each asset. In other words, for each return series, and thus for each column in the multivariate return series `returns`, we need to compute the average value and standard deviations.

These calculations are made easy by using the function `apply` with as first argument the return data file, the second argument is the value of `2` indicating  that the calculation should be column-wise, while the third argument is the name of the function that needs to be applied on each column. 

*** =instructions
- Compute the vector of average returns on those four investments using the R command `apply(returns,2,"mean")` and call this `vmeans`.
- Do the same to compute the vector standard deviations and call this `vsd`.
- Complete the R instructions to produce the scatter plot of average returns with respect to standard deviations. 

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
re_prices <- re_prices/as.numeric(re_prices[1])
comm_prices <-  comm_prices/as.numeric(comm_prices[1])


### plot

prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
returns <- Return.calculate(prices)
returns <- returns[(-1),]
temp <- c( as.numeric(eq_prices), as.numeric(bond_prices),as.numeric(re_prices), as.numeric(comm_prices)   )
ylim <- c( min( temp ) , 1.4*max(temp) )
plot.zoo(eq_prices , main="Performance across asset classes",ylab="", xlab="",ylim=ylim)
lines(bond_prices,col="red")
lines(re_prices,col="blue")
lines(comm_prices,col="purple")
legend("topleft", legend=c("Equities (ticker: SPY)","Bonds (ticker: AGG)", "Real estate (ticker: VEIEX)",
                           "Commodities (ticker: GSG)") , col=c("black","red","blue","purple") , lwd = 1 ,ncol=1)

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# vector of means
vmeans <- 
# vector of standard deviations
vsd    <- 
# scatter plot
plot( , vmeans,col="gray",xlim=c(0,0.10))

text( vsd ,  vmeans ,  labels=colnames(returns), cex= 0.7)` 


```


*** =solution
```{r}
# vector of means
vmeans <- apply(returns,2,"mean")
# vector of standard deviations
vsd <- apply(returns,2,"sd")
# scatter plot
plot(vsd,vmeans,col="gray",xlim=c(0,0.10))
text( vsd , vmeans,  labels=colnames(returns), cex= 0.7)
abline(h=0,lty=3)
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1  key:b7d7806b87
## The covariance matrix

The assets' volatilities reflect the individual risks of the asset. This is what matters the most. Investors want to reduce risk while maximizing gains. Volatilities reflect to the investor the amount of risk in a portfolio caused by each asset, which is dependent on the return volatility. 

In this exercise you will compute and analyze the covariance, and correlation matrix on the monthly returns of the four asset classes from the previous exercise. To refresh, these asset classes are: equities, bonds, real-estate, and commoditites. To create these matrices you will use the standard functions `cov()` and `cor()`. 

In your workspace are the monthly investments as `returns`, and the vector of standard deviations `vsd` that you created previously.

*** =instructions
- Use `diag(vsd^2)` create a vector of the diagonal matrix with the variances on the diagonal. Call this `diag_cov`. 
- Use `cov()` to compute the covariance matrix of returns. Call this `cov_matrix`.
- Use `cor()`to compute the correlation matrix of returns. Call this `cor_matrix`.
- Verify that the covariance between bond returns and equity returns equals the product between their standard deviations and correlation, by running the pre-loaded code.

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
# vector of means
vmeans <- apply(returns,2,"mean")
# vector of standard deviations
vsd <- as.numeric(apply(returns,2,"sd"))
```

*** =sample_code
```{r}
# Create a matrix with variances on the diagonal


# Create a covariance matrix of returns


# Create a correlation matrix of returns


# Verify covariances equal the product of standard deviations and correlation
cov_matrix[1,2] == cor_matrix[1,2]*vsd[1]*vsd[2]
```


*** =solution
```{r}
# Create a matrix with variances on the diagonal
diag_cov <- diag(vsd^2)

# Create a covariance matrix of returns
cov_matrix <- cov(returns)

# Create a correlation matrix of returns
cor_matrix <- cor(returns)


# Verify covariances equal the product of standard deviations and correlation
cov_matrix[1,2] == cor_matrix[1,2]*vsd[1]*vsd[2]
```

*** =sct
```{r}
# sct code
#1st
test_object("diag_cov")

#2nd
test_object("cov_matrix")

#3rd
test_object("cor_matrix")

#4th
test_output_contains("cov_matrix[1,2] == cor_matrix[1,2]*vsd[1]*vsd[2]", incorrect_msg = "Oops! Be sure to run the last line of code loaded in your script!")

success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1   key:21e408b8c65335ed2599fcb8ff64b5c9b352c374
## Matrix-based calculation of portfolio mean and variance


When $w$ is the column-matrix of portfolio weights, $\mu$ the column-matrix of expected returns, and $\Sigma$ the return covariance matrix. Then the portfolio expected return is $w'\mu$, and the portfolio variance is $w'\Sigma w$.

You will practice matrix multiplication in R using the `%*%` function, instead of the standard `*`. In addition you will transpose the matrices by using the standard function `t()`. Remember that transposing a matrix is simply changing the rows of the matrix to the columns.


*** =instructions
- Create a vector of the weights of a portfiol that is invested 40% in equities, 40% in bonds, 10% in real estate, and 10% in commodities. Call this new variable `weights`.
- Calculate the portfolio returns using `Return.portfolio`, and rebalance your weights monthly. Assign this to `preturns`.
- Calculate the annualized mean, and the annualized volatility of `preturns`.



- Compute the annualized mean and volatility of the portfolio return series. 
- To replicate this with matrix notation, first complete the code to compute the column-matrix of portfolio weights and
expected returns and the covariance matrix. 
- Now use the matrix products to compute the annualized mean return and volatility.

*** =hint
- annualized mean = 12 * mean(preturns)
- annualized volatility = sqrt(12) * sd(preturns)

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
re_prices <- re_prices/as.numeric(re_prices[1])
comm_prices <-  comm_prices/as.numeric(comm_prices[1])

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]


```

*** =sample_code
```{r}
# the monthly returns on the four assets are preloaded as  returns
# define vector of weights
weights <-  
# compute portfolio returns
preturns <- Return.portfolio(returns, weights,rebalance_on="months")
# print annualized mean and volatility

# turn weights and mean returns into a column-matrix
weights <- as.matrix(weights)
mu <- as.matrix(apply(returns,2,"mean"))
# sigma is the estimated covariance matrix
sigma <- 
# transsposed matrix
tweights <- t(weights) 
# annualized portfolio mean
12*(tweights%*% )
# annualized volatility
sqrt(12)*sqrt( tweights%*%sigma%*%  )
```

*** =solution
```{r}
# define vector of weights
weights <-   c(0.4,0.4,0.1,0.1)
preturns <- Return.portfolio(returns, weights,rebalance_on="months")
# Annualized mean and volatility
12*mean(preturns)
sqrt(12)*sd(preturns)
# turn weights and mean returns into a column-matrix
weights <- as.matrix(weights)
mu <- as.matrix(apply(returns,2,"mean"))
# sigma is the estimated covariance matrix
sigma <- cov(returns)
# transsposed matrix
tweights <- t(weights)
# transsposed matrix
tweights <- t(weights) 
# annualized portfolio mean
12*(tweights%*%mu )
# annualized volatility
sqrt(12)*sqrt( tweights%*%sigma%*%weights  )
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```


--- type:VideoExercise lang:r xp:50 skills:1   key:ba9b12d382
## The portfolio's risk budget

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v2/hls-ch3_3.master.m3u8

--- type:NormalExercise lang:r xp:100 skills:1 key:0931e83c3a402b2fb2d78958981928a327428e4d
## Whodunit

In the console, you see the monthly volatility of the portfolio invested for 40% in equities, 40% in bonds, 10% in real estate and 10% in commodities. 

Let us now use the technology of risk budgeting to find out how much % of the total portfolio volatility is caused by each of the positions.  

To do so, we will use the function [StdDev](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/StdDev).

*** =instructions
- Set `vol_budget` <- StdDev(returns,portfolio_method="component",
       weights=c(0.4,0.4,0.1,0.1))` and print this variable;
- Combine the weights and the percentage risk contributions in a table called `weights_percrisk`;
- Print the table and note how different the percentage risk contributions are compared to the portfolio weights. 

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
#
print("Monthly volatility of 40/40/10/10 portfolio in equities, bonds, real estate and commodities")
print( StdDev(returns,weights=c(0.4,0.4,0.1,0.1)))
```

*** =sample_code
```{r}
# define vol_budget
vol_budget
# make table
weights_percrisk <-
colnames(weights_percrisk) <- c( "weights" , "perc risk contrib")
# print the table

```

*** =solution
```{r}
# solution code
# define vol_budget
vol_budget <- StdDev(returns,portfolio_method="component",weights=c(0.4,0.4,0.1,0.1))
# make table
weights_percrisk<- cbind( c(0.4,0.4,0.1,0.1) ,  vol_budget$pct_contrib_StdDev)
colnames(weights_percrisk) <- c( "weights" , "perc risk contrib")
# print the table
print(weights_percrisk)
 
  
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

