---
title       : Performance drivers
description : In addition to studying portfolio performance based on the observed portfolio return series, it is relevant to find out how individual (expected) returns, volatilities and correlations interact to determine the total portfolio performance. 

--- type:VideoExercise lang:r xp:50 skills:1  key:bf1fc7dc803e342b4475c296bbebc2bab9b26f32
## The drivers in case of two assets

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v6/hls-ch3_1.master.m3u8

--- type:MultipleChoiceExercise lang:r xp:50 skills:1   key:27fc122215
## Driver 1: The assets' individual performance

The video reviewed the three types of drivers for a portfolio's performance: (i) the individual performance of the assets in terms of risk and return, (ii) the portfolio weight of each of the assets, (iii) the correlation between the asset returns.

Let us now analyze some data to grasp better the intuition of this result. In this example you will consider investing—with monthly frequency—in US equities and US bonds. Each asset's returns are stored in your workspace as `returns_equities`, and
`returns_bonds`. In addition, we consider the portfolio that is invested 60/40, meaning that every month you invest 60% in equities, and 40% bonds. These portfolio returns are stored as `returns_6040`.

Which of the following statements about the relationship between portfolio performance (investing in both equities and bonds) and the individual assets' performance (investing in only one of them) is true. 

*** =instructions
- Investing entirely in `returns_equities` has a lower risk than investing in the portfolio. 
- The portfolio mean return equals the position weighted sum of the component mean returns. You can test this using: `all.equal(mean(returns_6040), 0.6 * mean(returns_equities) + 0.4 * mean(returns_bonds))`.
- The investment value evolution of the bond is rather smooth because of the high standard deviation of the bond returns.
- None of the above statements are correct.

*** =hint
The proof is in the pudding. Use the code in the instructions in the console and you will find the solution to the problem.

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])

### plot
weights <- c(0.6,0.4)
prices <- cbind(eq_prices,bond_prices)
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_6040 <- Return.portfolio(returns, weights,rebalance_on="months")
# check: all.equal( as.numeric(returns_6040),as.numeric(0.6*returns[,1]+0.4*returns[,2])  )
prices_6040 <- zoo(cumprod(1+returns_6040),order.by=time(returns_6040))
temp <- c( as.numeric(eq_prices), as.numeric(bond_prices) )
ylim <- c( min( temp ) , max(temp) )
plot.zoo(eq_prices , main="Equity-bond portfolios",ylab="", xlab="",ylim=ylim)
lines(bond_prices,col="red")
lines(prices_6040,col="blue")
legend("topleft", legend=c("Equities (ticker: SPY)","Bonds (ticker: AGG)","60/40 Equities-Bonds") , col=c("black","red","blue") , lwd = 1 )

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
```

*** =sct
```{r}
msg1 <- "Risk is measured by the volatility (standard-deviation)!"
msg2 <- "Good job!"
msg3 <- "Bonds have a low risk, and limited reward."
msg4 <- "Try running some of the code we provided!"
test_mc(2, feedback_msgs = c(msg1, msg2, msg3, msg4)) 
success_msg("Good job!")
```

--- type:NormalExercise lang:r xp:100 skills:1     key:69c5664fdb
## Driver 2: the choice of portfolio weights

Investors can optimize the choice of weight to obtain the highest risk-adjusted return, as measured by the portfolio Sharpe ratio.

In the special case of investing the total portfolio value in only two assets, there is only one weight to determine, since the weight on the second asset equals one minus the weight of the first asset. 

Let us do this in the case of a portfolio invested US equities and US bonds. We will be using the brute force approach of trying a large number of possible weights and keeping the weight that yields the highest value for the portfolio Sharpe ratio (assuming a zero risk free rate).   


*** =instructions
- Create a vector called `grid` using `seq()` that begins at 0, ends at 1, by and increment of 0.01.
- Initialize empty vector `vsharpe` with the same length as `grid`. A popular way of doing this is by creating a vector that contains NA's using function [rep()](http://www.rdocumentation.org/packages/base/functions/rep). You will replace these NA's in the loop that you will create next.
- In the for loop, you will compute the Sharpe ratio for each of the possible weights in `grid`.
- The first command in the for-loop selects the i-th element of grid and stores it in object `weight`, which changes in each iteration.  
- You want to see how the portfolio return changes with a changing weight. Create an object `preturns` that equals the sum of `weight` times `returns_equities`, and `(1-weight)` times `returns_bonds`.
- Next, you will replace the NAs in `vsharpe` with the annualized sharpe ratio (`SharpeRatio.annualized()`) of `preturns`.
- Fill in the plot function where potential weights (`grid`) is plotted on the x-axis, and the Sharpe ratios on the y-axis.

*** =hint
To calculate your portfolio returns, your code should look like: `preturns <- weight * returns_equities + (1 - weight) * returns_bonds`.

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=as.Date("2016-06-30"),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=as.Date("2016-06-30"),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
set.seed(0)
```

*** =sample_code
```{r}
# Create a grid


# Initialize an empty vector for sharpe ratios
vsharpe <- rep(NA, times = ___ )

# Create a for loop to calculate Sharpe ratios
for(i in 1:length(grid)) {
	weight <- 
	preturns <- 
	vsharpe[i] <-
}

# Plot weights and Sharpe ratio
plot(___, ___, xlab = "Weights", ylab= "Ann. Sharpe ratio")
abline(v = grid[vsharpe == max(vsharpe)], lty = 3)
```


*** =solution
```{r}
# Create a grid
grid <- seq(0, 1, 0.01)

# Initialize an empty vector for sharpe ratios
vsharpe <- rep(NA, times = length(grid))

# Create a for loop to calculate sharpe ratios
for(i in 1:length(grid)) {
	weight <- grid[i]
	preturns <- weight * returns_equities + (1 - weight) * returns_bonds
	vsharpe[i] <- SharpeRatio.annualized(preturns)
}

# Plot weights and sharpe ratio
plot(grid, vsharpe, xlab= "Weights", ylab= "Ann. Sharpe ratio")
abline(v = grid[vsharpe==max(vsharpe)], lty=3)
```

*** =sct
```{r}
#1 
test_object("grid", undefined_msg = "Looks like you need to create a vector of weights!", incorrect_msg = "Remember that the weights need to start at 0, and end 1 by an increment of 0.01!")
#2
test_object("vsharpe", undefined_msg = "Oops! You forgot to create an empty vector for the sharpe ratios!", incorrect_msg = "Remember that `vsharpe` needs to be the same length as `grid`.")

test_function("plot", c("x", "y", "xlab", "ylab"))
test_function("abline", c("v", "lty"))
#3
#test_expression_output(
#"for(i in 1:length(grid)) {
#	weight <- grid[i]
#	preturns <- weight * returns_equities + (1-weight) * returns_bonds
#	vsharpe[i] <- preturns
#}", incorrect_msg = "Make sure your for loop is constructed properly!")


# sct code
success_msg("Well done! The portfolio that is 30% invested in equities, 70% in bonds has the largest possible Sharpe ratio.")
```

--- type:MultipleChoiceExercise lang:r xp:50 skills:1     key:f4f41f6b81
## Driver 3: The correlation between the asset returns

The third driver of portfolio performance is the correlation between the asset returns. Generally speaking, the correlation tells you how two asset returns tend to move together.

The correlation of assets has important consequences in overall portfolio performance. This correlation is important because it can reduce volatility through diversification, or reducing overall correlation. In fact, the lower the correlation, the more succesful the portfolio tends to be in regards to partially offsetting large losses in one asset with only a minor loss, or even a gain in another asset. 

In the extreme case of two identical asset returns, the correlation will be 1, and there is no diversification potential. In the other extreme case where, if one asset return is above average, and the other is almost always below average, the correlation is negative. The correlation is 0 when the asset returns are independent of eachother.

As an exercise, suppose you have an equally weighted portfolio of two assets. Their correlation jumps from 0 to 0.5. Then the portfolio variance:    

*** =instructions
- Decreases.
- Increases.
- Does not change.
- This cannot be determined with the provided information.

*** =hint
Use the R code and compute yourself how the variance changes.

*** =pre_exercise_code
```{r}

```


*** =sct
```{r}
msg1 <- "Not quite! Increased correlation increases risk."
msg2 <- "Great work! Having correlated assets can increase potential risk. Correlated asset prices rise and fall together. So when you suffer a loss in one asset there is a greater chance of suffering a loss on the other asset!"
msg3 <- "Not quite! Give it another go."
msg4 <- "Note quite! Re-read the exercise."
test_mc(2, feedback_msgs = c(msg1, msg2, msg3, msg4)) 
success_msg("Great work!")
```



--- type:NormalExercise lang:r xp:100 skills:1 key:b6a986b0e53bd119933fc39df94f21f2bf1e4318
## Interpreting correlation

Now you will learn how to compute the correlation between equity returns and bond returns. Just like volatilities, these correlations are dynamic. Therefore you need to distinguish between a static analysis that calculates correlations over a complete sample, and a dynamic analysis that calculates correlations over a rolling sample. This is a similar analysis as you did for the time-varying performance evaluation in terms of mean return and volatility. 

In this exercise you will learn 3 new functions from the PerformanceAnalytics package:  [chart.Scatter()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/chart.Scatter), [chart.Correlation()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/chart.Correlation), and [chart.RollingCorrelation()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/chart.RollingCorrelation). 

*** =instructions
- Plot the equity returns (`returns_equities`) against the bond returns (`returns_bonds`) using the function `chart.Scatter()` with the bond returns on the x-asis. Do you see a relation? 
- Compute the correlation between the variables `returns_equities` and `returns_bonds` using `cor()`.
- Merge `return_equities`, and `returns_bonds` using `merge()`. Call this `returns`.
- Compute and visualize the correlation again, using [chart.Correlation()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/chart.Correlation) with `returns_bonds` and `returns_equities` as argument, as well as the width argument specifying the length of the rolling estimation window.
- Compute the rolling 24-month estimates of the bond-equity correlation using the function `chart.RollingCorrelation()`. Note that `returns_bonds` is the so-called "benchmark asset", and should be included as the second argument.

*** =hint
`chart.RollingCorrelation()` uses two time-series for the argument `R`, and the `width` is the number of months.

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
```

*** =sample_code
```{r}
# Create a scatter plot


# Find the correlation


# Merge returns_equities and returns_bonds 


# Find and visualize the correlation using chart.Correlation


# Visualize the rolling estimates using chart.RollingCorrelation
chart.RollingCorrelation(___, ___, width = ___)


```

*** =solution
```{r}
# Create a scatter plot
chart.Scatter(returns_bonds, returns_equities)

# Find the correlation
cor(returns_equities, returns_bonds)

# Merge returns_equities and returns_bonds 
returns <- merge(returns_equities,returns_bonds)

# Find and visualize the correlation using chart.Correlation
chart.Correlation(returns)

# Visualize the rolling estimates using chart.RollingCorrelation
chart.RollingCorrelation(returns_equities, returns_bonds, width = 24)
```

*** =sct
```{r}
# sct code
#1st
test_function("chart.Scatter", c("x", "y"), not_called_msg = "Oops! Did you create a scatter plot?", incorrect_msg = "Be sure to plot bond returns on the correct axis!")

#2nd
test_function("cor", c("x", "y"),  not_called_msg = "Be sure to find the correlation of returns!")

#3rd
test_object("returns", undefined_msg = "Hey, it looks like you didn't merge the asset returns!", eval = F)

#4th
test_function("chart.Correlation", c("R"), not_called_msg = "Oops! It looks like you didn't chart the corrlelation of `returns`.", incorrect_msg = "Did you chart the correlation of `returns`?")

#5th
test_function("chart.RollingCorrelation", c("Ra", "Rb", "width"), not_called_msg = "Did you chart the rolling correlation of your asset returns?", incorrect_msg = "Be sure to use the vectors `returns_equities` and `returns_bonds`, and supply the proper window length!")

success_msg("Well done!")
```


--- type:VideoExercise lang:r xp:50 skills:1 key:a2866e000af4e20577dc0d48d46765e2da1a7d9b
## Using matrix notation

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v2/hls-ch3_2.master.m3u8

--- type:NormalExercise lang:r xp:100 skills:1 key:080c6863fc
## Making a risk-reward scatter diagram

In this example you have decided to extend your investment opportunity by creating a portfolio that consists of US equities ETF (SPY), US bonds ETF (AGG), a real estate investment trust (VEIEX), and an ETF tracking in the GSCI commodities index (GSG). The plot in the environment displays the performance of these investments.

A good way to visualize the relative attractivenss of investments in terms of risk and rewards is to make a scatter plot of the average returns against the portfolio volatilities. In order to do this you need to the averages and volatilities for each asset. This corresponds to each column in the return series `returns`. 

These calculations are made easy by using the function [apply()](http://www.rdocumentation.org/packages/base/functions/apply) with as first argument the return data, the second argument is the value of `2` indicating  that the calculation should be column-wise, while the third argument is the name of the function that needs to be applied on each column. 

*** =instructions
- Compute the vector of average returns on those four investments using `apply()` and call this `means` (Note that you could have used `colMeans()` as well!).
- Do the same to compute the vector standard deviations and call this `sds`.
- Create a scatter plot using the base plot function, where volatilities are the on x axis, and means on the y axis.
- We've added labels and a reference line to your plot. Don't change the code!


*** =hint
In order to calculate column-wise means and standard deviations, you will use the [apply()](http://www.rdocumentation.org/packages/base/functions/apply) function. Look at the documentation if you need help.

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
re_prices <- re_prices/as.numeric(re_prices[1])
comm_prices <-  comm_prices/as.numeric(comm_prices[1])


### plot

prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
returns <- Return.calculate(prices)
returns <- returns[(-1),]
temp <- c( as.numeric(eq_prices), as.numeric(bond_prices),as.numeric(re_prices), as.numeric(comm_prices)   )
ylim <- c( min( temp ) , 1.4*max(temp) )
plot.zoo(eq_prices , main="Performance across asset classes",ylab="", xlab="",ylim=ylim)
lines(bond_prices,col="red")
lines(re_prices,col="blue")
lines(comm_prices,col="purple")
legend("topleft", legend=c("Equities (ticker: SPY)","Bonds (ticker: AGG)", "Real estate (ticker: VEIEX)",
                           "Commodities (ticker: GSG)") , col=c("black","red","blue","purple") , lwd = 1 ,ncol=1)

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# Create a vector of returns 
means <- apply(___, 2, "___")
  
# Create a vector of standard deviation


# Create a scatter plot
plot(___, ___)
text(sds, means, labels=colnames(returns), cex= 0.7)
abline(h = 0, lty = 3)

```


*** =solution
```{r}
# Create a vector of returns 
means <- apply(returns, 2, "mean")
  
# Create a vector of standard deviation
sds <- apply(returns, 2, "sd")

# Create a scatter plot
plot(sds, means)
text(sds, means, labels = colnames(returns), cex = 0.7)
abline(h = 0, lty = 3)
```

*** =sct
```{r}
#1st
test_function("apply", c("X", "MARGIN", "FUN"), not_called_msg = "Be sure to calculate column-wise means!", incorrect_msg = "Did you specify the correct function?", index = 1)

#2nd
test_function("apply", c("X", "MARGIN", "FUN"), not_called_msg = "Oops! Did you calculate column-wise standard deviations?", incorrect_msg = "Did you specify the correct function?", index = 2)

#3rd
test_function("plot", c("x", "y"), incorrect_msg = "Oops! Are the standard deviations plotted on the correct axis?")


test_student_typed("text(sds, means, labels = colnames(returns), cex = 0.7)", not_typed_msg = "Oops! Did you alter the code we provided?!")

test_function("abline", c("h"))



success_msg("Well done! Take a look the plot you just created. Do you see you any patterns?")
```

--- type:NormalExercise lang:r xp:100 skills:1  key:b7d7806b87
## The covariance matrix

The covariance matrix is crucial in determining the portfolio variance in the general case of $N$ assets. Remember that its element on row $i$ and column $j$ corresponds to the covariance of the $i$ th and $j$ th return. Recall also that the covariance of two return series is is the product between their volatilities and their correlation, and that the covariance of an asset return with itself is its variance.

In this exercise you will compute and analyze the covariance, and correlation matrix on the monthly returns of the four asset classes from the previous exercise. To refresh, these asset classes are: equities, bonds, real-estate, and commoditites. To create these matrices you will use the standard functions `cov()` and `cor()`. 

In your workspace are the monthly investments as `returns`, and the vector of standard deviations `sds` that you created previously.

*** =instructions
- Create a diagonal matrix that contains the variances on the diagonal. You can use the function [diag()](http://www.rdocumentation.org/packages/base/functions/diag) to do this, using a squared `sds` as the only argument. Call this `diag_cov`. 
- Use `cov()` to compute the covariance matrix of returns. Call this `cov_matrix`.
- Use `cor()`to compute the correlation matrix of returns. Call this `cor_matrix`.
- Verify that the covariance between bond returns and equity returns equals the product between their standard deviations and correlation, by running the pre-loaded code.

*** =hint
Provide `returns` to both `cov()` and `cor()`.

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
# vector of means
means <- apply(returns,2,"mean")
# vector of standard deviations
sds <- as.numeric(apply(returns,2,"sd"))
```

*** =sample_code
```{r}
# Create a matrix with variances on the diagonal


# Create a covariance matrix of returns


# Create a correlation matrix of returns


# Verify covariances equal the product of standard deviations and correlation
all.equal(cov_matrix[1,2], cor_matrix[1,2] * sds[1] * sds[2])
```


*** =solution
```{r}
# Create a matrix with variances on the diagonal
diag_cov <- diag(sds^2)

# Create a covariance matrix of returns
cov_matrix <- cov(returns)

# Create a correlation matrix of returns
cor_matrix <- cor(returns)

# Verify covariances equal the product of standard deviations and correlation
all.equal(cov_matrix[1,2], cor_matrix[1,2] * sds[1] * sds[2])
```

*** =sct
```{r}
# sct code
#1st
test_object("diag_cov", undefined_msg = "Oops! You forgot to create a vector of covariances.", incorrect_msg = "Take a look at the instructions again. Be sure to calculate the covariance correctly!")

#2nd
test_object("cov_matrix", undefined_msg = "Hey, it looks like you forgot to create a covariance matrix!", incorrect_msg = "Use `cov()` to create your matrix!")

#3rd
test_object("cor_matrix", undefined_msg = "Did you create your correlation matrix?", incorrect_msg = "Use `cor()` to create your correlation matrix!")

#4th
test_function("all.equal", c("target", "current"))

success_msg("Well done! These matrices can help you in your calculations, and are also a good reference to see the relationship between your assets.")
```

--- type:NormalExercise lang:r xp:100 skills:1   key:21e408b8c65335ed2599fcb8ff64b5c9b352c374
## Matrix-based calculation of portfolio mean and variance

When $w$ is the column-matrix of portfolio weights, $\mu$ the column-matrix of expected returns, and $\Sigma$ the return covariance matrix. Then the portfolio expected return is $w'\mu$, and the portfolio variance is $w'\Sigma w$.

You will practice matrix multiplication in R using the `%*%` function, instead of the standard `*`. In addition you will transpose the matrices by using the standard function `t()`. Remember that transposing a matrix is simply changing the rows of the matrix to the columns.

The weights, vector of means, and the covariance matrix are pre-loaded in your workspace as,`weights`, `vmeans`, and `sigma`, respectively.

*** =instructions
- Convert weights to a matrix called `w` using `as.matrix()`.
- Convert the vector of means to a matrix called `mu` using `as.matrix()`.
- Calculate portfolio mean monthly return. Remember the function `t()` transposes a vector.
- Calculate the portfolio volatility.

*** =hint

Reference the formulas in the exercise description to do your calculations. 

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
re_prices <- re_prices/as.numeric(re_prices[1])
comm_prices <-  comm_prices/as.numeric(comm_prices[1])

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
# Define a vector of weights
weights <- c(0.4, 0.4, 0.1, 0.1)
# create a vector of mean returns
vmeans <- apply(returns, 2, "mean")
# Create a covariance matrix of returns sigma
sigma <- cov(returns)
```

*** =sample_code
```{r}
# Create a weight matrix w


# Create a matrix of returns


# Calculate portfolio mean monthly returns


# Calculate portfolio variance
```

*** =solution
```{r}
# Create a weight matrix w
w <- as.matrix(weights)

# Create a matrix of returns
mu <- as.matrix(vmeans)

# Calculate portfolio mean monthly returns
t(w) %*% mu

# Calculate portfolio variance
sqrt(t(w) %*% sigma %*% w)
```

*** =sct
```{r}
#1
test_object("weights", undefined_msg = "Make sure you create a vector of weights!", incorrect_msg = "Oops! It looks like you used the wrong weights!")

#2
test_object("w", undefined_msg = "It looks like you need to make your matrix of weights!", incorrect_msg = "Make sure you use the function `as.matrix()`!")
#3
test_object("mu", undefined_msg = "Hey! You forgot to create a matrix of mean returns!", incorrect_msg = "Make sure you convert your calculations to a matrix!")

#5
test_output_contains("t(w) %*% mu", incorrect_msg = "Make sure you multiply by the transpose of w!")
# sct code
success_msg("Well done!")
```

--- type:VideoExercise lang:r xp:50 skills:1   key:ba9b12d382
## The portfolio's risk budget

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v2/hls-ch3_3.master.m3u8

--- type:NormalExercise lang:r xp:100 skills:1 key:0931e83c3a402b2fb2d78958981928a327428e4d
## Who did it?

In the previous video you saw the difference between a captial allocation budget, and a risk budget. In this exercise you will construct a risk budget, and discover how large each assets percent risk contribution is in the total portfolio volatility. 

For this last exercise you will calculate the risk contributions for a portfolio that is again invested 40% in equities, 40% in bonds, 10% in real estate, and 10% in commodities. Function [StdDev()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/StdDev) plays an important role in this exercise. The `StdDev()` function creates a list of the assets' standard deviation (`$StdDev`), their risk contribution (`$contribution`), and their percent risk contribution (`$pct_contrib_StdDev`). 

You will be using three arguments in the `StdDev()` function to do this calculation. The first is `R`, a vector, matrix, data frame, time series or zoo object of returns. The second is `portfolio_method`, which you will be setting to `component`, and the third is `weights`.

The object `returns` is loaded in your workspace.

*** =instructions
- Create a vector of the portfolio weights. Remember, order matters! 
- Calculate your volatility budget using `StdDev()`. Set `portfolio_method = "component"` and `weights` equal to the created vector of `weights`. Call this `vol_budget`.
- Combine the weights and the percentage risk contributions in a table called `weights_percrisk` using `cbind()`.
- Print the table and note how different the percentage risk contributions are compared to the portfolio weights. 

*** =hint
If you're struggling with the `StdDev()` function, look at the exercise description. Everything you need is there!

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
#
print("Monthly volatility of 40/40/10/10 portfolio in equities, bonds, real estate and commodities")
print( StdDev(returns,weights=c(0.4,0.4,0.1,0.1)))
```

*** =sample_code
```{r}
# Create portfolio weights


# Create volatility budget


# Make a table of weights and risk contribution

colnames(weights_percrisk) <- c("weights", "perc vol contrib")

# Print the table

```

*** =solution
```{r}
# Create portfolio weights
weights <- c(0.4, 0.4, 0.1, 0.1)

# Create volatility budget
vol_budget <- StdDev(returns, portfolio_method = "component", weights = weights)

# Make a table of weights and risk contribution
weights_percrisk <- cbind(weights, vol_budget$pct_contrib_StdDev)
colnames(weights_percrisk) <- c("weights", "perc vol contrib")

# Print the table
print(weights_percrisk)
 
  
```

*** =sct
```{r}
#1
test_object("weights", undefined_msg = "Be sure to create a vector of portfolio weights!", incorrect_msg = "Did you use the correct weights? Order matters!")

#2
test_function("StdDev", c("R", "portfolio_method", "weights"), not_called_msg = "Oops! Be sure to use the `StdDev()` function.", incorrect_msg = "Look over `vol_budget`. Did you supply the correct values for the arguments in `StdDev()`?")

#3
test_object("weights_percrisk", undefined_msg = "It looks like you didn't merge your weights and risk contributions!", incorrect_msg = "Make sure you use `cbind()` to merge `weights` and the percent contribution from `vol_budget`!")

#4
test_output_contains("weights_percrisk")
success_msg("Well done! Note that the percentage volatility risk caused by the bonds is much less than their portfolio weight")
```

