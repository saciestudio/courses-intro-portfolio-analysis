---
title       : Performance drivers
description : In addition to studying portfolio performance based on the observed portfolio return series, it is relevant to find out how individual (expected) returns, volatilities and correlations interact to determine the total portfolio performance. 

--- type:VideoExercise lang:r xp:50 skills:1  key:bf1fc7dc803e342b4475c296bbebc2bab9b26f32
## The drivers in case of two assets

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v6/hls-ch3_1.master.m3u8

--- type:MultipleChoiceExercise lang:r xp:50 skills:1   key:27fc122215
## Driver 1: The assets' individual performance

So far in the previous chapters you have seen that there are three types of drivers for a portfolio's performance: (i) the individual performance of the assets in terms of risk and return, (ii) the portfolio weight of each of the assets, (iii) the correlation between the asset returns. 
  
You will now explore how the portfolio mean return and volatility depends on the mean returns and volatility of the assets that a portfolio is invested in. In this example you will consider investing—with monthly frequency—in US equities and US bonds. Each asset's returns are stored in your workspace as `returns_equities`, and `returns_bonds`, in addition the portfolio returns are stored as `returns_6040`. You have a portfolio that is invested 60/40, meaning that every month you invest 60% in equities, and 40% bonds.

Which of the following statements about the relationship between portfolio performance (investing in both equities and bonds) and the individual assets' performance (investing in only one of them) is false. 

*** =instructions
- Investing entirely in `returns_equities` has a lower risk than investing in the portfolio. 
`all.equal(0.6 * sd(returns_equities) + 0.4 * sd(returns_bonds), sd(returns_equities))`.
- The portfolio mean return equals the position weighted sum of the component mean returns. This is written as: `all.equal(mean(returns_6040), 0.6 * mean(returns_equities) + 0.4 * mean(returns_bonds))`.
- Investing `returns_bonds` has a lower risk and thus a higher reward!
- None of the above statements are correct.

*** =hint
The proof is in the pudding. Use the code in the instructions in the console and you will find the solution to the problem.

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])

### plot
weights <- c(0.6,0.4)
prices <- cbind(eq_prices,bond_prices)
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_6040 <- Return.portfolio(returns, weights,rebalance_on="months")
# check: all.equal( as.numeric(returns_6040),as.numeric(0.6*returns[,1]+0.4*returns[,2])  )
prices_6040 <- zoo(cumprod(1+returns_6040),order.by=time(returns_6040))
temp <- c( as.numeric(eq_prices), as.numeric(bond_prices) )
ylim <- c( min( temp ) , max(temp) )
plot.zoo(eq_prices , main="Equity-bond portfolios",ylab="", xlab="",ylim=ylim)
lines(bond_prices,col="red")
lines(prices_6040,col="blue")
legend("topleft", legend=c("Equities (ticker: SPY)","Bonds (ticker: AGG)","60/40 Equities-Bonds") , col=c("black","red","blue") , lwd = 1 )

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
```

*** =sct
```{r}
msg1 <- "Risk is measured by the volatility (standard-deviation)!"
msg2 <- "Good job!"
msg3 <- "Bonds have a low risk, and limited reward."
msg4 <- "Try running some of the code we provided!"
test_mc(2, feedback_msgs = c(msg1, msg2, msg3, msg4)) 
success_msg("Good job!")
```

--- type:NormalExercise lang:r xp:100 skills:1     key:69c5664fdb
## Driver 2: the choice of porfolio weights

Investors can optimize the choice of weight to obtain the highest risk-adjusted return, as measured by the portfolio Sharpe ratio.

In the special case of investing the total portfolio value in only two assets, there is only one weight to determine, since the weight on the second asset equals one minus the weight of the first asset. 

Let us do this in the case of a portfolio invested US equities and US bonds. We will be using the brute force approach of trying a large number of possible weights and keeping the weight that yields the highest value for the portfolio Sharpe ratio.   


*** =instructions
- Create a vector called `grid` using `seq()` that begins at 0, ends at 1, by and increment of 0.01.
- Initialize empty vector `vsharpe` with the same length as `grid`.
- Create a for loop that creates `weight` equal to `grid[i]`. 
- Within your loop create `preturns` which is the value of the returns of `returns_equities` and `returns_bonds`, where `returns_equities` has a weight of `weight`.
- Fill your `vsharpe` vector with the annualized sharpe ratio (`SharpeRatio.annualized()`) of `preturns`.
- Fill in the plot function where the x-axis are the weights, and the y-axis the sharpe ratios.

*** =hint
hint

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
```

*** =sample_code
```{r}
# Create a grid


# Initialize an empty vector for sharpe ratios


# Create a for loop to calculate sharpe ratios


# Plot weights and sharpe ratio
plot(___, ___, xlab = "Weights", ylab= "Ann. Sharpe ratio")
abline(v = grid[vsharpe == max(vsharpe)], lty = 3)
```


*** =solution
```{r}
# Create a grid
grid <- seq(0, 1, 0.01)

# Initialize an empty vector for sharpe ratios
vsharpe <- rep(NA,length(grid))

# Create a for loop to calculate sharpe ratios
for(i in 1:length(grid)) {
	weight <- grid[i]
	preturns <- weight * returns_equities + (1-weight) * returns_bonds
	vsharpe[i] <- preturns
}

# Plot weights and sharpe ratio
plot(grid, vsharpe, xlab= "Weights", ylab= "Ann. Sharpe ratio")
abline(v = grid[vsharpe==max(vsharpe)], lty=3)
```

*** =sct
```{r}
#1 
test_object("grid", undefined_msg = "Looks like you need to create a vector of weights!", incorrect_msg = "Remember that the weights need to start at 0, and end 1 by an increment of 0.01!")
#2
test_object("vsharpe", undefined_msg = "Oops! You forgot to create an empty vector for the sharpe ratios!", incorrect_msg = "Remember that `vsharpe` needs to be the same length as `grid`.")
#3
test_correct(
  test_expression_output(
"for(i in 1:length(grid)) {
	weight <- grid[i]
	preturns <- weight * returns_equities + (1-weight) * returns_bonds
	vsharpe[i] <- preturns
}", incorrect_msg = "Make sure your for loop is constructed properly!")
)

# sct code
success_msg("Well done!")
```

--- type:MultipleChoiceExercise lang:r xp:50 skills:1     key:f4f41f6b81
## Driver 3: The correlation between the asset returns

The third driver of portfolio performance is the correlation between the asset returns. Generally speaking, the correlation tells you how two asset returns tend to move together.

The correlation of assets has important consequences in overall portfolio performance. This correlation is important because it can reduce volatility through diversification, or reducing overall correlation. In fact, the lower the correlation, the more succesful the portfolio tends to be in regards to partially offsetting large losses in one asset with only a minor loss, or even a gain in another asset. 

In the extreme case of two identical asset returns, the correlation will be 1, and there is no diversification potential. In the other extreme case where, if one asset return is above average, and the other is almost always below average, the correlation is negative. The correlation is 0 when the asset returns are independent of eachother.

As an exercise, suppose you have an equally weighted portfolio of two assets. Their correlation jumps from 0 to 0.5. Then the portfolio variance:    

*** =instructions
- Decreases.
- Increases.
- Does not change.
- This cannot be determined with the provided information.

*** =hint
When correlation increases, potential risk increases. What is one measurement of risk?

*** =pre_exercise_code
```{r}

```


*** =sct
```{r}
msg1 <- "Not quite! Increased correlation increases risk."
msg2 <- "Great work! Having correlated assets can increase potential risk. Correlated asset prices rise and fall together. So when you suffer a loss in one asset there is a greater chance of suffering a loss on the other asset!"
msg3 <- "Not quite! Give it another go."
msg4 <- "Note quite! Re-read the exercise."
test_mc(2, feedback_msgs = c(msg1, msg2, msg3, msg4)) 
success_msg("Great work!")
```



--- type:NormalExercise lang:r xp:100 skills:1 key:b6a986b0e53bd119933fc39df94f21f2bf1e4318
## Interpreting correlation

Now you will learn how to compute the correlation between equity returns and bond returns. Just like volatilities, these correlations are dynamic. Therefore you need to distinguish between a static analysis that calculates correlations over a complete samples, and a dynamic analysis that calculates correlations over a rolling sample. This is a similar analysis as you did for the time-varying performance evaluation in terms of mean return and volatility. 

In this exercise you will learn 3 new functions from the PerformanceAnalytics package. These are [chart.Scatter()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/chart.Scatter)`, [chart.Correlation()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/chart.Correlation), and [chart.RollingCorrelation()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/chart.RollingCorrelation). 

*** =instructions
- Plot the equity returns (`returns_equities`) against the bond returns (`returns_bonds`) using the function `chart.Scatter()` with the bond returns on the x-asis. Do you see a relation? 
- Compute the correlation between the variables `returns_equities` and `returns_bonds` using the standard function `cor()`.
- Merge `return_equities`, and `returns_bonds` using `merge()`. Call this `returns`.
- Compute and visualize the correlation again, except using [chart.Correlation()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/chart.Correlation) with `returns` as the argument. 
- Commpute the rolling 24-month estimates of the bond-equity correlation using the function `chart.RollingCorrelation()`, use the arguments `R`, and `width`. 

*** =hint
`chart.RollingCorrelation()` uses two time-series for the argument `R`, and the `width` is the number of months.

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
prices <- cbind(eq_prices,bond_prices)
colnames(prices) <- c("equities","bonds")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
returns_bonds <- returns$bonds
returns_equities <- returns$equities
```

*** =sample_code
```{r}
# Create a scatter plot


# Find the correlation


# Merge returns_equities and returns_bonds 


# Find and visualize the correlation using chart.Correlation


# Visualize the rolling estimates using chart.RollingCorrelation
chart.RollingCorrelation(___, ___, width = ___)


```

*** =solution
```{r}
# Create a scatter plot
chart.Scatter(returns_bonds, returns_equities)

# Find the correlation
cor(returns_equities, returns_bonds)

# Merge returns_equities and returns_bonds 
returns <- merge(returns_equities,returns_bonds)

# Find and visualize the correlation using chart.Correlation
chart.Correlation(returns)

# Visualize the rolling estimates using chart.RollingCorrelation
chart.RollingCorrelation(returns_equities, returns_bonds, width = 24)
```

*** =sct
```{r}
# sct code
#1st
test_function("chart.Scatter", c("x", "y"), not_called_msg = "Oops! Did you create a scatter plot?", incorrect_msg = "Be sure to plot bond returns on the correct axis!")

#2nd
test_function("cor", c("x", "y"),  not_called_msg = "Be sure to find the correlation of returns!")

#3rd
test_object("returns", undefined_msg = "Hey, it looks like you didn't merge the asset returns!")

#4th
test_function("chart.Correlation", c("R"), not_called_msg = "Oops! It looks like you didn't chart the corrlelation of `returns`.", incorrect_msg = "Did you chart the correlation of `returns`?")

#5th
test_function("chart.RollingCorrelation", c("Ra", "Rb", "width"), not_called_msg = "Did you chart the rolling correlation of your asset returns?", incorrect_msg = "Be sure to use the vectors `returns_equities` and `returns_bonds`, and supply the proper window length!")

success_msg("Well done!")
```


--- type:VideoExercise lang:r xp:50 skills:1 key:a2866e000af4e20577dc0d48d46765e2da1a7d9b
## The general case using matrix notation

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v2/hls-ch3_2.master.m3u8

--- type:NormalExercise lang:r xp:100 skills:1 key:080c6863fc
## Making a risk-reward scatter diagram

Investors know that each asset that they invest in has risk, and that each asset performs differently. That's why you will not only invest in US equities and US bonds, but you will *diversify* your portfolio by investing in real estate, commoditites, among others! 

In this example you have decided to extend your investment opportunity by creating a portfolio that consists of US equities ETF (SPY), US bonds ETF (AGG), a real estate investment trust (VEIEX), and an ETF tracking in the GSCI commodities index (GSG). The plot in the environment displays the performance of these investments.

A good way to visualize the relative attractivenss of investments in terms of risk and rewards is to make a scatter plot of the average returns against the portfolio volatilities. In order to do this you need to the averages and volatilities for each asset. This corresponds to each column in the return series `returns`. 

These calculations are made easy by using the function [apply()](http://www.rdocumentation.org/packages/base/functions/apply) with as first argument the return data, the second argument is the value of `2` indicating  that the calculation should be column-wise, while the third argument is the name of the function that needs to be applied on each column. 

*** =instructions
- Compute the vector of average returns on those four investments using the R command `apply(returns, 2, "mean")` and call this `means`.
- Do the same to compute the vector standard deviations and call this `sds`.
- Create a scatter plot using the base plot function, where volatilities are the on x axis, and means on the y axis.
- We've added labels and a reference line to your plot. Don't change the code!


*** =hint
In order to calculate column-wise means and standard deviations, you will use the [apply()](http://www.rdocumentation.org/packages/base/functions/apply) function. Look at the documentation if you need help.

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
re_prices <- re_prices/as.numeric(re_prices[1])
comm_prices <-  comm_prices/as.numeric(comm_prices[1])


### plot

prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
returns <- Return.calculate(prices)
returns <- returns[(-1),]
temp <- c( as.numeric(eq_prices), as.numeric(bond_prices),as.numeric(re_prices), as.numeric(comm_prices)   )
ylim <- c( min( temp ) , 1.4*max(temp) )
plot.zoo(eq_prices , main="Performance across asset classes",ylab="", xlab="",ylim=ylim)
lines(bond_prices,col="red")
lines(re_prices,col="blue")
lines(comm_prices,col="purple")
legend("topleft", legend=c("Equities (ticker: SPY)","Bonds (ticker: AGG)", "Real estate (ticker: VEIEX)",
                           "Commodities (ticker: GSG)") , col=c("black","red","blue","purple") , lwd = 1 ,ncol=1)

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# Create a vector of returns 
means <- apply(___, 2, "___")
  
# Create a vector of standard deviation


# Create a scatter plot
plot(___, ___)
text(sds, means, labels=colnames(returns), cex= 0.7)
abline(h = 0, lty = 3)

```


*** =solution
```{r}
# Create a vector of returns 
means <- apply(returns, 2, "mean")
  
# Create a vector of standard deviation
sds <- apply(returns, 2, "sd")

# Create a scatter plot
plot(sds, means)
text(sds, means, labels = colnames(returns), cex = 0.7)
abline(h = 0, lty = 3)
```

*** =sct
```{r}
#1st
test_function("apply", c("X", "MARGIN", "FUN"), not_called_msg = "Be sure to calculate column-wise means!", incorrect_msg = "Did you specify the correct function?", index = 1)

#2nd
test_function("apply", c("X", "MARGIN", "FUN"), not_called_msg = "Oops! Did you calculate column-wise standard deviations?", incorrect_msg = "Did you specify the correct function?", index = 2)

#3rd
test_function("plot", c("x", "y"), incorrect_msg = "Oops! Are the standard deviations plotted on the correct axis?")
test_output_contains("text(sds, means, labels = colnames(returns), cex = 0.7)", incorrect_msg = "Oops! Did you alter the code we provided?!")
test_output_contains("abline(h = 0, lty = 3", "Hey! Did you change our code?")

success_msg("Well done! Take a look the plot you just created. Do you see you any patterns?")
```

--- type:NormalExercise lang:r xp:100 skills:1  key:b7d7806b87
## The covariance matrix

The assets' volatilities reflect the individual risks of the asset. This is what matters the most. Investors want to reduce risk while maximizing gains. Volatilities reflect to the investor the amount of risk in a portfolio caused by each asset, which is dependent on the return volatility. 

In this exercise you will compute and analyze the covariance, and correlation matrix on the monthly returns of the four asset classes from the previous exercise. To refresh, these asset classes are: equities, bonds, real-estate, and commoditites. To create these matrices you will use the standard functions `cov()` and `cor()`. 

In your workspace are the monthly investments as `returns`, and the vector of standard deviations `sds` that you created previously.

*** =instructions
- Use `diag(sds^2)` create a vector of the diagonal matrix with the variances on the diagonal. Call this `diag_cov`. 
- Use `cov()` to compute the covariance matrix of returns. Call this `cov_matrix`.
- Use `cor()`to compute the correlation matrix of returns. Call this `cor_matrix`.
- Verify that the covariance between bond returns and equity returns equals the product between their standard deviations and correlation, by running the pre-loaded code.

*** =hint
Proivde `returns` to both `cov()` and `cor()`.

*** =pre_exercise_code
```{r}
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
# vector of means
means <- apply(returns,2,"mean")
# vector of standard deviations
sds <- as.numeric(apply(returns,2,"sd"))
```

*** =sample_code
```{r}
# Create a matrix with variances on the diagonal


# Create a covariance matrix of returns


# Create a correlation matrix of returns


# Verify covariances equal the product of standard deviations and correlation
cov_matrix[1,2] == cor_matrix[1,2] * sds[1] * sds[2]
```


*** =solution
```{r}
# Create a matrix with variances on the diagonal
diag_cov <- diag(sds^2)

# Create a covariance matrix of returns
cov_matrix <- cov(returns)

# Create a correlation matrix of returns
cor_matrix <- cor(returns)

# Verify covariances equal the product of standard deviations and correlation
cov_matrix[1,2] == cor_matrix[1,2] * sds[1] * sds[2]
```

*** =sct
```{r}
# sct code
#1st
test_object("diag_cov", undefined_msg = "Oops! You forgot to create a vector of covariances.", incorrect_msg = "Take a look at the instructions again. Be sure to calculate the covariance correctly!")

#2nd
test_object("cov_matrix", undefined_msg = "Hey, it looks like you forgot to create a covariance matrix!", incorrect_msg = "Use `cov()` to create your matrix!")

#3rd
test_object("cor_matrix", undefined_msg = "Did you create your correlation matrix?", incorrect_msg = "Use `cor()` to create your correlation matrix!")

#4th
test_output_contains("cov_matrix[1,2] == cor_matrix[1,2]*vsd[1]*vsd[2]", incorrect_msg = "Oops! Make sure you didn't change the last line of code we provide you!")

success_msg("Well done! These matrices can help you in your calculations, and are also a good reference to see the relationship between your assets.")
```

--- type:NormalExercise lang:r xp:100 skills:1   key:21e408b8c65335ed2599fcb8ff64b5c9b352c374
## Matrix-based calculation of portfolio mean and variance

NEEDS REWORKING 

When $w$ is the column-matrix of portfolio weights, $\mu$ the column-matrix of expected returns, and $\Sigma$ the return covariance matrix. Then the portfolio expected return is $w'\mu$, and the portfolio variance is $w'\Sigma w$.

You will practice matrix multiplication in R using the `%*%` function, instead of the standard `*`. In addition you will transpose the matrices by using the standard function `t()`. Remember that transposing a matrix is simply changing the rows of the matrix to the columns.

The object `returns` is pre-loaded in your workspace!


*** =instructions
- Create a vector of weights called `weights`.
- Convert weights to a matrix called `w` using `as.matrix()`.
- Calculate the row means of returns using `apply()`, and convert this to a matrix called `mu`.
- Create a covariance matrix of returns called `sigma`.
- Calculate portfolio mean monthly return. Remember the function `t()` transposes a vector.
- Calculate the portfolio volatility.

*** =hint

Reference the formulas in the exercise description to do your calculations. 

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
re_prices <- re_prices/as.numeric(re_prices[1])
comm_prices <-  comm_prices/as.numeric(comm_prices[1])

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# Define a vector of weights


# Create a weight matrix w


# Calculate mean returns mu


# Create a covariance matrix of returns sigma


# Calculate portfolio mean monthly returns


# Calculate portfolio volatility
```

*** =solution
```{r}
# Define a vector of weights
weights <- c(0.4, 0.4, 0.1, 0.1)

# Create a weight matrix w
w <- as.matrix(weights)

# Calculate mean returns mu
mu <- as.matrix(apply(returns, 2, “mean”))

# Create a covariance matrix of returns sigma
sigma <- cov(returns)

# Calculate portfolio mean monthly returns
t(w) %*% mu

# Calculate portfolio volatility
sqrt(t(w) %*% sigma %*% w)
```

*** =sct
```{r}
#1
test_object("weights", undefined_msg = "Make sure you create a vector of weights!", incorrect_msg = "Oops! It looks like you used the wrong weights!")

#2
test_object("w", undefined_msg = "It looks like you need to make your matrix of weights!", incorrect_msg = "Make sure you use the function `as.matrix()`!")
#3
test_object("mu", undefined_msg = "Hey! You forgot to create a matrix of mean returns!", incorrect_msg = "Make sure you convert your calculations to a matrix!")
#4
test_object("sigma", undefined_msg = "Oops! You didn't make a covariance matrix!", incorrect_msg = "Whoops! You didn't create your covariance matrix properly. Try using `cov()`!")
#5
test_output_contains("t(w) %*% mu", incorrect_msg = "Make sure you multiply by the transpose of w!")
# sct code
success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1
## Annualizing using matrices 

In the previous exercise you practiced calclulating returns, and volatility using matrix notation. In this exercise you will practice annualizing those returns! You will also compare the outputs from matrix calculations and the standard calculations you have been practicing.

The matrices you created in the last exercise are loaded in your workspace as `w`, `mu`, and `sigma`. In addition the return series of created from using `Return.portfolio()` is loaded as `preturns`. You will compare this to the matrices.

*** =instructions
- Calculate the annualized portfolio returns using matrices.
- Calculate the annualized volatility using matrices.
- Calculate the annualized portfolio returns using `preturns`.
- Calculate the annualized volatility using `preturns`.

*** =hint

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
eq_prices <- eq_prices/as.numeric(eq_prices[1])
bond_prices <-  bond_prices/as.numeric(bond_prices[1])
re_prices <- re_prices/as.numeric(re_prices[1])
comm_prices <-  comm_prices/as.numeric(comm_prices[1])

###
newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]

weights <- c(0.4, 0.4, 0.1, 0.1)

# Create a weight matrix w
w <- as.matrix(weights)

# Calculate mean returns mu
mu <- as.matrix(apply(returns, 2, “mean”))

# Create a covariance matrix of returns sigma
sigma <- cov(returns)
```


*** =sample_code
```{r}
# Calculate the annualized portfolio returns using matrices


# Calculate the annualized volatility using matrices


# Calculate the annualized portfolio returns using preturns


# Calculate the annualized volatility using preturns


```

*** =solution
```{r}
# Calculate the annualized portfolio returns using matrices
12 * (t(w) %*% mu)

# Calculate the annualized volatility using matrices
sqrt(12) * sqrt(t(w) %*% sigma %*% w)

# Calculate the annualized portfolio returns using preturns
12 * mean(preturns)

# Calculate the annualized volatility using preturns
sqrt(12) * sd(preturns)

```

*** =sct
```{r}
test_output_contains("12 * (t(w) %*% mu)", index = 1)
test_output_contains("sqrt(12) * sqrt(t(w) %*% sigma %*% w)", index = 1)
test_output_contains("12 * mean(preturns)", index = 2)
test_output_contains("sqrt(12) * sd(preturns)", index = 2)

# sct code
success_msg("Well done!")
```



--- type:VideoExercise lang:r xp:50 skills:1   key:ba9b12d382
## The portfolio's risk budget

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v2/hls-ch3_3.master.m3u8

--- type:NormalExercise lang:r xp:100 skills:1 key:0931e83c3a402b2fb2d78958981928a327428e4d
## Who did it?

In the previous video you saw the difference between a captial allocation budget, and a risk budget. In this exercise you will construct a risk budget. You will disover how large each assets percent risk contribution is in the total portfolio volatility. 

For this last exercise you will calculate the risk contributions for a portfolio that is invested *40% in equities, 40% in bonds, 10% in real estate, and 10% in commodities*. To do so, you will use the function [StdDev()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/StdDev). The `StdDev()` function creates a list of the assets' standard deviation (`$StdDev`), their risk contribution (`$contribution`), and their percent risk contribution (`$pct_contrib_StdDev`). 

You will be using three arguments in the `StdDev()` function to do this calculation. The first is `R`, a vector, matrix, data frame, time series or zoo object of returns. The second is `portfolio_method`, which you will be setting to `component`, and the third is `weights`.

The object `returns` is loaded in your workspace.

*** =instructions
- Create a vector of the portfolio weights. 
- Calculate your volatility budget using `StdDev()`. Set `portfiol_method = "component" and `weights` equal to the vector of weights. Call this `vol_budget`.
- Combine the weights and the percentage risk contributions in a table called `weights_percrisk` using `cbind()`.
- Print the table and note how different the percentage risk contributions are compared to the portfolio weights. 

*** =hint
If you're struggling with the `StdDev()` function, look at the exercise description. Everything you need is there!

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
eq_prices <- get.hist.quote(instrument="SPY",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
bond_prices <- get.hist.quote(instrument="AGG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
re_prices <- get.hist.quote(instrument="VEIEX",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")
comm_prices <- get.hist.quote(instrument="GSG",start=as.Date("2006-08-31"),end=Sys.Date(),quote="AdjClose",quiet=T,compression="m")

newdates <- seq(as.Date(time(bond_prices ))[2], length=nrow(bond_prices ), by="1 month") - 2
eq_prices <- xts(eq_prices,newdates)
bond_prices <- xts(bond_prices,newdates)
re_prices <- xts(re_prices,newdates)
comm_prices <- xts(comm_prices,newdates)
prices <- cbind(eq_prices,bond_prices,re_prices,comm_prices)
colnames(prices) <- c("equities","bonds","realestate","commodities")
# calculate returns
returns <- Return.calculate(prices)
returns <- returns[(-1),]
#
print("Monthly volatility of 40/40/10/10 portfolio in equities, bonds, real estate and commodities")
print( StdDev(returns,weights=c(0.4,0.4,0.1,0.1)))
```

*** =sample_code
```{r}
# Create portfolio weights


# Create volatility budget


# Make a table of weights and risk contribution


# Print the table

```

*** =solution
```{r}
# Create portfolio weights
weights <- c(0.4, 0.4, 0.1, 0.1)

# Create volatility budget
vol_budget <- StdDev(returns, portfolio_method = "component", weights = weights)

# Make a table of weights and risk contribution
weights_percrisk <- cbind(weights, vol_budget$pct_contrib_StdDev)

# Print the table
print(weights_percrisk)
 
  
```

*** =sct
```{r}
#1
test_object("weights", undefined_msg = "Be sure to create a vector of portfolio weights!", incorrect_msg = "Did you use the correct weights? Order matters!")

#2
test_function("StdDev", c("R", "portfolio_method", "weights"), not_called_msg = "Oops! Be sure to use the `StdDev()` function.", incorrect_msg = "Look over `vol_budget`. Did you supply the correct values for the arguments in `StdDev()`?")

#3
test_object("weights_percrisk", undefined_msg = "It looks like you didn't merge your weights and risk contributions!", incorrect_msg = "Make sure you use `cbind()` to merge `weights` and the percent contribution from `vol_budget`!")

#4
test_output_contains("weights_percrisk")
success_msg("Well done!")
```

