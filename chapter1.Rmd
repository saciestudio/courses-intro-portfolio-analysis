---
title       : The building blocks 
description : Asset returns and portfolio weights; those are the building blocks of a portfolio return. This chapter is about computing those portfolio weights and returns in R.  

--- type:VideoExercise lang:r xp:50 skills:1 key:b1edf0455cddc24b5691f41bc0bb1b0e9f7e4c1a
## Welcome to the course

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v2/hls-ch1_1.master.m3u8

--- type:MultipleChoiceExercise lang:r xp:50 skills:1 key:5df9cc8be3e5717ab2d100eb52a85328bc27d243
## Getting a grasp of the basics

Welcome to Introduction to Portfolio Analysis! In the last video you were given a brief overview of some of the key concepts in portfolio analysis. The goal of every investor is to make profits while limiting the amount of risk involved. Investors create strategies to reduce these risks.

Which of the following is true about investment:

*** =instructions
- Portfolios that consist of very different assets are poorly diversified.
- Portfolios that consist of very different assets are diversified.
- Investors reduce risk by investing in a fewer number of assets.
- Portfolio strategies cannot be tested.

*** =hint
If youâ€™re struggling, remember that diversification is about making portfolios in which the loss on one asset can be compensated by the gains on the other assets in the portfolio.

*** =pre_exercise_code
```{r}
#
```

*** =sct
```{r}
msg1 <- "Close! Investors can reduce their risk by investing in a number of assets that are independent of each other!"
msg2 <- "Good job! Diversified portfolios reduce risk by offsetting loss with a potential gain in another asset!"
msg3 <- "Almost! It's not always smart to put all of your eggs in one basket."
msg4 <- "Not quite. You can test an investmet strategy on historical data!"

test_mc(2, feedback_msgs = c(msg1, msg2, msg3, msg4))
```

--- type:NormalExercise lang:r xp:100 skills:1 key:3eba4bd8de6fe4123ea68cc159aa5e8a117fc27d
## Get a feel for the data

The choice of investment matters even when the underlying risky assets are similar. As a first example, let us consider the stock price of the Coca Cola Company and the PepsiCo company from January 2003,  until today.  

The time series plot shows you the value evolution of one dollar invested in each company. As an exercise, plot the time series showing the relative value of an investment in the Coca Cola company, compared to the value of an investment in PepsiCo. To do this exercise, you can us the corresponding price series, available as the variables `ko` and `pep` in your workspace. 

*** =instructions
- Define `ko_pep` as the ratio expressing the value of the share price of the Coca Cola company in terms
of the share price of PepsiCo
- Use [plot.zoo()](http://www.rdocumentation.org/packages/zoo/functions/plot.zoo) to visualize the variation in this ratio over time. 
- Use [abline()](http://www.rdocumentation.org/packages/graphics/functions/abline) to include a horizontal line at `h=1`.
- Note that when the value of the ratio increases, `ko` outperforms `pep` and vice versa
- Note that when the value of the ratio is larger than 1, the performance of `ko` since January 2003 is higher than that of `pep`. Therefore, as a reference line, use `abline` to include a horizontal line at `h=1`.


*** =hint
`plot.zoo()` only needs one argument, ko_pep.

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
ko <- get.hist.quote(instrument="KO",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T)
pep <- get.hist.quote(instrument="PEP",start=as.Date("2003-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T)

# 
ko <- ko/as.numeric(ko[1])
pep <- pep/as.numeric(pep[1])

#
plot.zoo(ko, ylim=c( min(c(min(ko),min(pep))) ,  max(c(max(ko),max(pep))) ) , ylab="", xlab="")
lines(pep,col="red")
legend("topleft", legend=c("Coca-Cola","PepsiCo") , col=c("black","red") , lwd = 1 )
```

*** =sample_code
```{r}
# Define ko_pep 
ko_pep <- 

# Make a time series plot of ko_pep
  
  
# Note that when the value of the ratio increases, the price of the share of Coca Cola Company increases more than the price of PepsiCo, and vice versa
  
# Add as a reference, a horizontal line at 1
  
  
# Where the value of the ratio is larger than one, the Coca Cola Company outperforms PepsiCo (when evaluating since January 2003)
```

*** =solution
```{r}
# Define ko_pep 
ko_pep <- ko/pep

# Make a time series plot of ko_pep
plot.zoo(ko_pep)  

# Note that, when the value of the ratio increases, the price of the share of Coca Cola Company increases more than the price of PepsiCo, and vice versa

# Add, as a reference a horizontal line at 1
abline(h = 1)  

# Where the value of the ratio is larger than one, the Coca Cola Company outperforms PepsiCo (when evaluating since January 2003)
```

*** =sct
```{r}
#1st instruction
test_object("ko_pep", incorrect_msg = "Did you correctly define the ratio of `ko` and `pep`?")

#2nd instruction
test_student_typed("plot.zoo(ko_pep)", not_typed_msg = "Did you create the time series plot of `ko_pep`?")

#3rd instruction
test_student_typed("abline(h=1)", not_typed_msg = "Did you create the abline at 1?")
# sct code
test_error()
success_msg("Well done!")
```

--- type:VideoExercise lang:r xp:50 skills:1 key:8edc78ed1db55bc7450ceaeb586c9c5f4be2ffb2
## The portfolio weights

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v3/hls-ch1_2.master.m3u8


--- type:MultipleChoiceExercise lang:r xp:50 skills:1 key:d2c7c64108eb91da5a95275fe980d5b4aee3be95
## A first portfolio: buy-and-hold versus daily rebalancing

The choice of investment matters, even when the underlying risky assets are similar. As a second example, you will now consider the stock price of Apple and Microsoft from January 2006 until today. The time series plot shows you the value evolution of one dollar invested in each of them. 

It is time to consider our first portfolio. The portfolio approach that you will use to invest is to invest half of the budget in Apple, and the other half of your budget in Microsoft. 
Over time, the portfolio weights will change. You will have two choices as an investor. The first choice is to be **passive and not trade any further**. This is called a *buy and hold* strategy. The second choice is to buy and trade at the close of each day that results in a **rebalance** of the portfolio such that your portfolio is equally invested in shares of Microsoft and Apple. This is a *rebalanced portfolio*. 

Which of the following statements is false?

*** =instructions
- By investing in a portfolio of risky assets, the portfolio payoff will be in between the minimum and maximum of the payoff of the underlying risky assets.
- By investing in a portfolio of risky assets, the risk of the portfolio payoff will be less than the maximum risk of the underlying risky assets.
- An investor needs to have a lot of capital to be able to invest in a portfolio of many assets. 
- Because the prices of Microsoft and Apple have evolved differently, the investor who spent initially half of his wealth on Microsoft and Apple ends up with a portfolio that is no longer equally invested. 

*** =hint
A large number of stocks trade at less than 100 USD a share.

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)# Its function get.hist.quote allows to download prices from Yahoo!Finance
library(xts) # Its function plot.zoo make simple, but attractive, time series plots
library(PerformanceAnalytics)
# download adjusted close prices (that is corrected for dividend payments and stock splits)
# dates have the format "YYYY-MM-DD"
aapl <- get.hist.quote(instrument="AAPL",start=as.Date("2005-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T)
msft <- get.hist.quote(instrument="MSFT",start=as.Date("2005-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T)
# 
aapl <- aapl/as.numeric(aapl[1])
msft <- msft/as.numeric(msft[1])
mixed <- 0.5*aapl + 0.5*msft

a <- Return.calculate(aapl, method="simple")
b <- Return.calculate(msft, method="simple")
ab <- 0.5*(a+b)
ab[1] <- 0
ew <- cumprod(1+ab)
time(ew) <- time(aapl)
#
plot.zoo(aapl, ylim=c( min(c(min(aapl),min(msft),min(ew),min(ab))) ,  max(c(max(aapl),max(msft),max(ew),max(ab))) ) , ylab="", xlab="")
lines(msft,col="red")
lines(mixed,col="blue")
lines(ew,col="purple")
legend("topleft", legend=c("Apple","Microsoft","50-50 buy and hold","50-50 rebalanced") , col=c("black","red","blue","purple") , lwd = 1 )
```

*** =sct
```{r}
test_mc(3) # if 3 is the correct option.
```



--- type:NormalExercise lang:r xp:100 skills:1 key:85a3e5f4f4ca30b9944167e9cbf5eb13692aa7bc
## Calculating portfolio weights when component values are given

An investor has 4000 USD invested in equities, 4000 USD invested in bonds, and 2000 USD invested in commodities. Compute the weights as the proportion invested in each of those three assets. 

*** =instructions
- Define the vector `values` as the vector holding these three values.
- Print the vector `weights` as the vector `values` divided by the total value (obtained by summing over the component values using the function `sum`).

*** =hint
`weights` are calculated by taking `values` and dividing by the `sum(values)`.

*** =pre_exercise_code
```{r}
# pec
```

*** =sample_code
```{r}
# Define the vector values


# Define the vector weights


# Print the resulting weights

```

*** =solution
```{r}
# Define the vector values
values <- c(4000,4000,2000)

# Define the vector weights
weights <- values/sum(values)

# Print the resulting weights
print(weights)
```

*** =sct
```{r}
# sct code
#1st instruction
test_object("values", incorrect_msg = "Did you use the correct dollar values for the `values` object?")

#2nd instruction
test_object("weights", incorrect_msg = "Did you calculate the weights correctly?")

success_msg("Well done! Remember that the weight of an asset is calculated by taking the value of the asset divided by the sum of values of all assets.")
```

--- type:MultipleChoiceExercise lang:r xp:50 skills:1 key:ca2625a363bea895fda8cc4f1d12f3a2cca25da3
## The weights of an equally weighted portfolio

The equally weighted portfolio is one of the most used portfolios. Suppose the portfolio is equally invested in $N$ assets. Let `N <- 100`. Use the R console to determine which of the following commands defines the weight vector for
ï¿¼an equally weighted portfolio.

*** =instructions
- `weights <- 1/N`
- `weights <- rep(1/N,N)`
- `weights <- rep(N, 1)`
- `weights <- rep(1/N, 1)`
*** =hint
The function `rep(arg1,arg2)` creates a vector in which `arg1` is replicated `arg2` times. When there are `N` assets, the length of the weight vector should be equal to `N`.

*** =pre_exercise_code
```{r}
# pec
```

*** =sct
```{r}
msg1 <- "Not quite! This creates a vector of one value!"
msg2 <- "That's right! This creates a vector of length `N`, or 100 where each value is the same!"
msg3 <- "Oops! This creates a vector of length 1."
msg4 <- "Not quite! This creates a vector of length 1, where the value is 1/100!"
test_mc(2, feedback_msgs = c(msg1, msg2, msg3, msg4)) 
```

--- type:NormalExercise lang:r xp:100 skills:1 key:ccb1301f85e423d2c1f28ba595bf9e688611fff5
## The weights of a market capitalization weighted portfolio

In a market capitalization weighted portfolio, the weights are given by the individual assets' market capitalization, divided by the sum of the market capitalizations of all assets. A typical example is the S&P 500 portfolio invested in the 500 largest companies listed on the US stock exchanges (NYSE, Nasdaq).  Note that dividing by the total value of the characteristic across all assets guarantees that the portfolio weights sum up to unity. 

As an exercise, inspect the distribution of market capitalization based weights when the portfolio is invested in 10 stocks. For this exercise you can use market capitalizations of 5, 8, 9, 20, 25, 100, 100, 500, 700 and 2000 million USD. 

*** =instructions
- Define the vector `marketcaps` holding the market capitalization
- Calculate the weights of `marketcaps` and assign them to `weights`
- Print a summary of `weights`
- Plot a histogram of `weights`

*** =hint
You can make a histogram in R using the function [hist()](http://www.rdocumentation.org/packages/graphics/functions/hist).

*** =pre_exercise_code
```{r}
# pec
```

*** =sample_code
```{r}
# Define marketcaps
 
  
# Compute the weights

  
# Inspect summary statistics

  
# Plot a histogram of weights
  
```

*** =solution
```{r}
# Define marketcaps
marketcaps <- c(5, 8, 9, 20, 25, 100, 100, 500, 700, 2000)

# Compute the weights
weights <- marketcaps/sum(marketcaps)

# Inspect summary statistics 
summary(weights)

# Plot a histogram of weights
hist(weights)
```

*** =sct
```{r}
# sct code
#1st instruction
test_object("marketcaps", incorrect_msg = "Did you use the given values for market caps?", undefined_msg = "Oops! Did you create a vector of `marketcaps`?")

#2nd instruction
test_object("weights", incorrect_msg = "Remember that weights are calculated by taking the market cap of an asset divided by the sum of all market caps.", undefined_msg = "Don't forget to create a vector of asset weights!")

#3rd instruction
test_student_typed("summary(weights)", not_typed_msg = "Make sure you print a summary of the weights!")

#4th instruction
test_output_contains("hist(weights)", incorrect_msg = "Make sure to create a histogram of `weights`!")

success_msg("Well done! Remember that market capitalizations are the market value of a company's shares, and that weights are calculated by taking the market cap and dividing by the sum of market caps for all assets in a portfolio. ")
```



--- type:VideoExercise lang:r xp:50 skills:1 key:e8205bb01833692ce3cb610117bb029180e68ee8
## The portfolio return
   

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v4/hls-ch1_3.master.m3u8

--- type:NormalExercise lang:r xp:100 skills:1 key:7a2a60bffa8920ebf2121e0ec548f767197060f0
## Calculation of portfolio returns

For your first exercise on calculating portfolio returns, you will verify that a portfolio return can be computed as the weighted average of the portfolio component returns. In other words, this means that a **portfolio return** is calculated by taking the sum of simple returns multiplied by the portfolio weights.

You will use three assets for this example.

Assume that you invested in three assets. Their initial values are 1000 USD, 5000 USD, 2000 USD respectively. Over time, the values change to 1100 USD, 4500 USD, and 3000 USD.

*** =instructions
- Create a vector of the initial asset values `in_values`. 
- Create a vector of the final values, `fin_values`. 
- Create a vector of the initial weights, `weights`.
- Use the simple return definition to compute the vector of returns on the three component assets. Assign return values to `returns`.
- Assign the portfolio returns to `preturns`.
- Verify that the weighted average portfolio return equals the percentage change in the total portfolio value using [all.equal()](http://www.rdocumentation.org/packages/base/functions/all.equal). Run the provided code.

*** =hint
Use the portfolio return formula to compute the simple portfolio return!

*** =pre_exercise_code
```{r}
# pec
```

*** =sample_code
```{r}
# Vector of initial value of the assets
in_values <- 
  
# Vector of final values of the assets
fin_values <-

# Weights as the proportion of total value invested in each assets
weights <-

# Vector of simple returns of the assets 
returns <- (___- ___)/___
  
# Compute portfolio return using the portfolio return formula
preturns <- sum(___*___)
  
# Verify that it matches with the percentage change in the portfolio value
all.equal(preturns,
          (sum(fin_values) - sum(in_values)) / sum(in_values))
```

*** =solution
```{r}
# Vector of initial of the assets
in_values <- c(1000,5000,2000)

# Vector of final values of the assets
fin_values <- c(1100,4500,3000)

# Weights as the proportion of total value invested in each assets
weights <-  in_values/sum(in_values)

# Vector of simple returns of the assets 
returns <- (fin_values - in_values)/in_values

# Compute portfolio return using the portfolio return formula
preturns  <- sum(weights*returns)

# Verify that it matches with the percentage change in the portfolio value
all.equal(preturns,
          (sum(fin_values) - sum(in_values))/sum(in_values))
```

*** =sct
```{r}
# sct code
#1st instruction
test_object("in_values", incorrect_msg = "Did you use the correct asset values?", undefined_msg = "Be sure to create a vector of initial values!")

#2nd instruction
test_object("fin_values", incorrect_msg = "Did you use the correct final asset values?", undefined_msg = "Be sure to create a vector of final values!")

#3rd instruction
test_object("returns", incorrect_msg = "Are you sure you calculated the simple return correctly?", undefined_msg = "Did you create a vector of returns?")

#4th instruction
test_object("weights", incorrect_msg = "Make sure you calculated weights correctly!", undefined_msg = "Oops! You need to create a vector called `weights`!")

#5th instruction
test_object("preturns", incorrect_msg = "Make sure you calculated the portfolio return correctly!", undefined_msg = "You need to calculate the portfolio returns!")

#6th instruction
test_student_typed("all.equal(preturns,
          (sum(fin_values) - sum(in_values))/sum(in_values))")

success_msg("Congratulations! You proved that portfolio returns are the weighted average of the portfolio compenent returns.
            Remember that **portfolio returns** are calculated by taking the sum of simple returns, multiplied by the portfolio weights.")
```

--- type:MultipleChoiceExercise lang:r xp:50 skills:1 key:6fda9fa37a19f2326c9e7164c8617f1936dc7124

## From simple to gross and multi-period returns   

The simple return $R$ expresses the percentage change in value of an investment. The corresponding so-called "gross" return is defined as the future value of 1 USD invested in the asset for one period, and is thus equal to *$1+R$*.

The gross return over two periods is obtained similarly. Let *$R_1$* be the return in the first period and *$R_2$* the return in the second period. Then the end-value of a 1 USD investment is $(1 +$*$R_1$*$) * (1 + $*$R_2$*$)$.
 

The corresponding simple return over those two periods is: $(1 +$*$R_1$*$) * (1 + $*$R_2$*$)-1$.

Suppose that you have an investment horizon of two periods. In the first period you make a 10% return. But in the second period you take a loss of 5%. 

Use the R console to compute the end value of a 1000 USD investment.

Which of the three following answers do you obtain?

*** =instructions
- End-value = 1155
- End-value = 1045
- End-value = 1050

*** =hint
If *$R_1$* is the return in the first period and *$R_2$* is the return in the second period, then the end-value of a 1 USD investment is $(1 +$*$R_1$*$) * (1 + $*$R_2$*$)$.

*** =pre_exercise_code
```{r}
# pec
```

*** =sct
```{r}
test_mc(2) # if 2 is the correct option.
```

--- type:MultipleChoiceExercise lang:r xp:50 skills:1 key:a189cd245c6e378938cab1356e5c01fcebd9b358

## The asymmetric impact of gains and losses  

It is important to be aware of the fact that a positive and negative return of the same magnitude do not compensate each other in terms of terminal wealth. Mathematically, this can be seen from the identity $(1+x)*(1-x)=1-x^2$, which is less than one. A 50% loss is thus not compensated by a 50% gain.  After a loss of 50%, what is the return needed to be at par again? Verify your answer in the R console.

*** =instructions
- 75%
- 100%
- 200%

*** =hint
In order to return to your initial value, what percent of your value after a loss do you need to return to your intial value?

*** =pre_exercise_code
```{r}
# pec
```

*** =sct
```{r}
test_mc(2) # if 2 is the correct option.
success_msg("Well done! After 50% loss you would need to double the amount of money you have remaining to return to your initial investment value.")
```


--- type:VideoExercise lang:r xp:50 skills:1 key:c9e758551130f685dc22840b3ede8cefc4642902
## The PerformanceAnalytics package


*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v3/hls-ch1_4.master.m3u8


--- type:NormalExercise lang:r xp:100 skills:1 key:1d4270da1d39343116d0e77f9b897e6b2127914f
## The time series of asset returns  

Calculating the returns for one period is pretty straightforward to do in R. When the returns need to be calculated for different dates the functions [Return.calculate()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/Return.calculate) and [Return.portfolio()](http://www.rdocumentation.org/packages/PerformanceAnalytics/functions/Return.portfolio), in the R package [PerformanceAnalytics](http://www.rdocumentation.org/packages/performanceanalytics/functions/performanceanalytics-package) are extremely helpful. They require the input data to be of the [xts-time series class](http://www.rdocumentation.org/packages/xts/functions/xts-package). You will explore the functionality of the `PerformanceAnalytics` package in this exercise. 

You have a portfolio invested in the Apple stock, and Microsoft stock. The prices for each stock are available in the variables `aapl` and `msft` in your workspace.

*** =instructions
- Load the packages `xts` and `PerformanceAnalytics` in your R session.
- Use the function [merge()](http://www.rdocumentation.org/packages/xts/functions/merge) to bind the variables `aapl` and `msft`. Call this `prices`.
- Print the first and last six rows of `prices` using `head` and `tail`.
- Use the function `Return.calculate()` with the only argument `prices` to compute for each date the return as the percentage change in the price compared to the previous date, call this `returns`.
- Print the first six rows of `returns`.
- Remove the first row of `returns`.

*** =hint
Look at the documentation for `merge()` if you need help combining your vectors!

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)
aapl <- get.hist.quote(instrument="AAPL",start=as.Date("2005-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T)
msft <- get.hist.quote(instrument="MSFT",start=as.Date("2005-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T)
```

*** =sample_code
```{r}
# Load the packages xts and PerformanceAnalytics 



# Define prices as the merged time series of aapl and msft
prices <-  merge(___ , ___)
colnames(prices) <- c("AAPL","MSFT")

# Print the first and last six rows of prices
 


# Create the variable returns using Return.calculate()  
 
  
# Print the first six rows of returns. Note that the first observation is NA, because there is no prior price.

  
# Remove the first row of returns
returns <- returns[-1, ]
 
```

*** =solution
```{r}
# Load the packages xts and PerformanceAnalytics 
library(xts)
library(PerformanceAnalytics)

# Define prices as the merged time series of aapl and msft
prices <-  merge(aapl,msft)
colnames(prices) <- c("AAPL","MSFT")

# Print the first and last six rows of prices
head(prices)
tail(prices)

# Create the variable returns using Return.calculate()  
returns <- Return.calculate(prices)  

# Print the first six rows of returns. Note that the first observation is NA, because there is no prior price.
head(returns)

# Remove the first row
returns <- returns[-1, ]
 
```

*** =sct
```{r}
# sct code 
#1st instruction
test_library_function(xts, not_called_msg = "Make sure to call the xts library!")
test_library_function(PerformanceAnalytics, not_called_msg = "Make sure to call the PerformanceAnalytics library!")

#2nd instruction
#test_object("prices", incorrect_msg = "Did you use the merge function properly? Also, be sure not to alter the #`colnames()` function!", undefined_msg = "You need to merge your return series!")

#3rd instruction
test_output_contains("head(prices)", incorrect_msg = "Oops! Be sure to look at the head of `prices`!")
test_student_typed("tail(prices)", not_typed_msg = "Oops! Be sure to look at the tail of `prices`!")

#4th instruction
test_object("returns", incorrect_msg = "Did you provide the correct object to `Return.calculate()`?", undefined_msg = "You need to create an object of returns!")

#5th instruction
test_output_contains("head(returns)", incorrect_msg = "It looks like you didn't print the head of your returns!")

#6th instruction
test_object("returns")

test_error()
success_msg("Well done! Notice that you removed the first row of your returns because they were `NA` values!")
```

--- type:NormalExercise lang:r xp:100 skills:1   key:7fd5556f94
## The time series of portfolio returns

In the previous exercise you create a variable called `returns` from the daily prices of stocks of Apple and Microsoft. In this exercise you will create two portfolios using the return series you previously created. The two portfolios will differ in one way, and that is the weighting of the assets.

In the last video you were introduced to two weighting strategies: the buy and hold strategy, and a monthly rebalancing strategy. In this exercise you will create a portfolio in which you donâ€™t rebalance, and one where you rebalance monthly. You will then visualize the portfolio returns of both.

You will use the function `Return.portfolio()` for your calculations. For this function you will provide three arguments: `R`, `weights`, and `rebalance_on`. `R` is a time series of returns, `weights` is a vector of asset returns, and `rebalance_on` specifies which calendar-period to rebalance on.  If you need help, be sure to check the documentation by clicking on the function!

`returns` is pre-loaded in your workspace.


*** =instructions
- Define the vector `weights` for two equally weighted assets.
- Create a portfolio using the buy and hold strategy using `Return.portfolio()`. Note, you do not need to specify a rebalance period. Call this `pf_bh`.
- Create a portfolio where you rebalance your weights monthly. Use `Return.portfolio()` with the argument `rebalance_on = "months"`. Call this `pf_rebal`.
- Plot the time series of each portfolio using `plot.zoo()`. 
- Note that `par(mfrow=c(2,1),mar=c(2,4,2,2))` is used to organize the plots you create. Do not alter this code.

*** =hint
- Remember that weights should always add to 1!
- Provide `returns` as the first arguments for `Return.portfolio()`, and `weights` second.

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)
library(xts)
library(PerformanceAnalytics)
aapl <- get.hist.quote(instrument="AAPL",start=as.Date("2005-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T)
msft <- get.hist.quote(instrument="MSFT",start=as.Date("2005-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T)

# define prices as the merged time series of aapl and msft
prices <-  merge(aapl,msft)
# print the first and last six rows of prices
returns <-  Return.calculate(prices)  
# remove the first row
returns <- returns[-1,]
colnames(returns) <- c("AAPL","MSFT")
```

*** =sample_code
```{r}
# Create the weights


# Create a portfolio using buy and hold
pf_bh <- Return.portfolio(R = ___, weights = ___)

# Create a portfolio rebalancing monthly 


# Plot the time-series
par(mfrow=c(2,1),mar=c(2,4,2,2))
```

*** =solution
```{r}

# Create the weights
weights <- c(0.5, 0.5)

# Create a portfolio using buy and hold
pf_bh <- Return.portfolio(returns, weights = weights)

# Create a portfolio rebalancing monthly 
pf_rebal <- Return.portfolio(returns, weights = weights, rebalance_on = "months")


# Plot the time-series
par(mfrow=c(2,1),mar=c(2,4,2,2))
plot.zoo(pf_bh)
plot.zoo(pf_rebal)
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1  key:6d949a6e63
##  The time series of weights 

In the previous exercise you explored the functionality of the `Return.portfolio()` function and created portfolios using two strategies. However, by setting the argument `verbose = TRUE` in `Return.portfolio()` you can create a list of beginning of period (BOP) and end of period (EOP) weights and values in addition to the portfolio returns, and contributions.

You can access these from the resultant list-object created from `Return.portfolio()`. The resultant list contains `$returns`, `$contributions`, `$BOP.Weight`, `$EOP.Weight`, `$BOP.Value`, and `$EOP.Value`.

In this exercise you will recreate the portfolios you made in the last exercise but extend it by creating a list of calculations using `verbose = TRUE`. You will then visualize the end of period weights of Apple.

The object `returns` is pre-loaded in your workspace.

*** =instructions
- Define the vector `weights` for two equally weighted assets.
- Create a portfolio of returns by using the buy and hold strategy and setting `verbose = TRUE`. Call this `pf_bh`.
- Create a portfolio of returns using the a monthly rebalancing strategy, and setting `verbose = TRUE`. Call this `pf_rebal`.
- Create a new object called `eop_weight_bh`using the end of period weights of `pf_bh`.
- Create a new object called `eop_weight_rebal` using the end of period weights of `pf_rebal`.
- Plot the end of period weights of Apple in `eop_weight_bh` using `plot.zoo()`
- Plot the end of period weights of Apple in `eop_weight_rebal` using `plot.zoo()`
- Note that `par(mfrow = c(2, 1), mar = c(2, 4, 2, 2))` is used to organize the plots you create. Do not alter this code.

*** =hint

*** =pre_exercise_code
```{r}
# pec
options(warn=-1)
library(tseries)
library(PerformanceAnalytics)
aapl <- get.hist.quote(instrument="AAPL",start=as.Date("2005-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T)
msft <- get.hist.quote(instrument="MSFT",start=as.Date("2005-12-31"),end=Sys.Date(),quote="AdjClose",quiet=T)

# define prices as the merged time series of aapl and msft
prices <-  merge(aapl,msft)
# print the first and last six rows of prices
returns <-  Return.calculate(prices)  
# remove the first row
returns <- returns[-1,]
colnames(returns) <- c("AAPL","MSFT")
```

*** = sample_code 
``` {r}
# Create the weights
c(0.5, 0.5)

# Create a portfolio using buy and hold
pf_bh <- Return.portfolio(returns, weights = weights, ___ )

# Create a portfolio that rebalances monthly
pf_rebal <- Return.portfolio(returns, weights = weights, rebalance_on = "months", ___ )

# Create end of eop_weight_bh


# Create eop_weight_reabl


# Plot end of period weights
par(mfrow = c(2, 1), mar=c(2, 4, 2, 2))
```

*** =solution 
```{r}
# Create the weights
weights <- c(0.5, 0.5)

# Create a portfolio using buy and hold
pf_bh <- Return.portfolio(returns, weights = weights, verbose = TRUE)

# Create a portfolio that rebalances monthly
pf_rebal <- Return.portfolio(returns, weights = weights, rebalance_on = "months", verbose = TRUE)

# Create end of eop_weight_bh
eop_weight_bh <- pf_bh$EOP.Weight

# Create eop_weight_reabl
eop_weight_rebal <- pf_rebal$EOP.Weight

# Plot end of period weights
par(mfrow = c(2, 1), mar = c(2, 4, 2, 2))
plot.zoo(eop_weight_bh$AAPL)
plot.zoo(eop_weight_rebal$AAPL)
```


*** =sct
```{r}
# sct code
#1
test_object("weights", incorrect_msg = "Remember that weights need to add to unity (1)!", undefined_msg = "Don't forget to create a vector of weights!")

#2
test_object("pf_bh", incorrect_msg = "You should set your weights argument equal to `weights` and `verbose = TRUE`!", undefined_msg = "Oops! You forgot to create a portfolio using a buy and hold technique.")

#3
test_object("pf_rebal", incorrect_msg = "You should set your `rebalance_on` argument to `months`, and `verbose = TRUE`!", undefined_msg = "Oops! You forgot to create a portfolio using a monthly rebalancing technique.")

#4
#test_object("eop_weight_bh", incorrect_msg = "Did you select the `$EOP.Weight` to create your end of period weight #vector?", undefined_msg = "Don't forget to create a vector of the end of period weights for your buy and hold #portfolio!")

#5
test_object("eop_weight_rebal", incorrect_msg = "Did you select the `$EOP.Weight` to create your end of period weight vector?", undefined_msg = "Don't forget to create a vector of the end of period weights for your monthly rebalanced portfolio!")

test_output_contains("par(mfrow = c(2,1), mar = c(2, 4, 2, 2))")
test_output_contains("plot.zoo(eop_weight_bh$AAPL)")
test_output_contains("plot.zoo(eop_weight_rebal$AAPL)")

success_msg("Well done!")
```
 
