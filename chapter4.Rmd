---
title       : Optimizing the portfolio 
description : We have up to now considered the portfolio weights as given. In this chapter you learn how to determine in R the portfolio weights that are optimal in terms of achieving a target return with minimum risk, while satisfying constraints on the portfolio weights.  
 
--- type:VideoExercise lang:r xp:50 skills:1 key:2d45c303bc2e49767a9cd744f15a31938a2ec7d9
## Modern portfolio theory of Harry Markowitz


*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v1/hls-ch4_1.master.m3u8

--- type:MultipleChoiceExercise lang:r xp:50 skills:1   key:139d7eabbd827860709b29f2a8d968614d1e3cb0
## Mean-variance based investing in DJIA stocks 

In this chapter you will explore portfolio optimization. For the upcoming exercises you will focus on the Dow Jones Industrial Average (DJIA) stocks. Like the S&P 500 portfolio studied in Chapter 2, the Dow Jones Industrial Average portfolio is an important reference portfolio for the US equity market. It is invested in 30 large publicly owned companies based in the United States.

You will be using the sample of monthly returns from January 1991 until December 2015. These return data are available in the workspace as the variable `returns`.   

Assume you are an investor that likes high returns with minimum risk. Which of the following statements is false:

*** =instructions
- You would rather invest all of your capital in Home Depot (ticker: HD) than in Caterpillar (ticker: CAT) because Home Depot has a higher average return, and lower risk.
- By combining investments, it may be possible to obtain a portfolio with a lower variance than the variance of the Exxon Mobil Corporationâ€™s stock (ticker: XOM).
- An investor can create a portfolio of the thirty Dow Jones Industrial Average stocks that offers a higher average return than Apple (ticker: AAPL)
- None of the above are true. 

*** =hint
The closer a stock is to the origin of the x-axis, the less risk it has. Likewise, the closer a stock is to the origin of the y-axis, the less reward it as. 

*** =pre_exercise_code
```{r}
# pec
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices <- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]

stockmu = apply( X = returns , MARGIN = 2 , FUN="mean")
stocksd = apply( X = returns , MARGIN = 2 , FUN="sd")

# make the scatter plot and add tickers

plot(stocksd,stockmu,col="gray" , xlab="Standard deviation (monthly)", ylab="Average return (monthly)",xlim=c(0,1.1*max(stocksd)),ylim=c(0,1*1*max(stockmu)))
text( stocksd[!is.element(names(stocksd),c("HD","CAT","XOM","AAPL"))] , 
       stockmu[!is.element(names(stocksd),c("HD","CAT","XOM","AAPL"))] ,  
      labels=colnames(returns )[!is.element(names(stocksd),c("HD","CAT","XOM","AAPL"))], cex= 0.7)
text( stocksd[c("HD","CAT","XOM","AAPL")]  ,  stockmu[c("HD","CAT","XOM","AAPL")] ,  labels=  c("HD","CAT","XOM","AAPL") , cex= 0.9,col="red")
```

*** =sct
```{r}
msg1 <- "That right! Home Depot has a lower monthly standard deviation and a higher monthly return than Caterpillar."
msg2 <- "Incorrect! Try again!"
msg3 <- "Oops! Try again!"
msg4 <- "Not quite!"
test_mc(1) 
```

--- type:NormalExercise lang:r xp:100 skills:1   key:8c67f73515
## Exploring monthly returns of the 30 DJIA stocks 

The 1991-2015 monthly returns on the 30 DJIA stocks are available in the workspace as the variable `returns`. This exercise will help you get comfortable with the data that you will be using for the remainder of the exercises.


*** =instructions
- Verify that `returns` is an object of the xts-class using the function [class()](http://www.rdocumentation.org/packages/base/functions/class).
- Create a vector of row means of `returns` using the function [rowMeans()](http://www.rdocumentation.org/packages/base/functions/colSums). Assign this to `row_means`.
- Plot `row_means` using `plot.zoo()`.
- Create a correlation matrix of the returns called `z`.
- Plot the histogram of the correlations between the monthly returns of the DJIA stocks. Because of the symmetry of the correlation matrix, you only need the lower triangular elements, which, for any square matrix `z`, you can select using `z[lower.tri(z)]`.

*** =hint
Remeber that you can use `cor()` to create a correlation matrix.

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# Verify the class of returns 


# Create a vector of row means


# Plot row_means


# Create a correlation matrix


# Plot the histogram of the correlation matrix

```

*** =solution
```{r}
# Verify the class of returns 
class(returns)

# Create a vector of row means
row_means <- rowMeans(returns)

# Plot row_means
plot.zoo(row_means)

# Create a correlation matrix
z <- cor(returns)

# Plot the histogram of the correlation matrix
hist(z[lower.tri(z)])
```

*** =sct
```{r}
#1
test_function("class", "x", not_called_msg = "Did you verify that `returns` is an xts-class object?")

#2
test_object("row_means", undefined_msg = "Did you calculate the row means of `returns`?", incorrect_msg = "Did you calculate the row means of `returns` correctly?")

#3
test_function("plot.zoo", "x", not_called_msg = "Be sure to plot the row means using `plot.zoo()`!")

#4
test_object("z", undefined_msg = "Hey, don't forget to create a correlation matrix called `z`!", incorrect_msg = "Did you use the correct function to make your correlation matrix?")

#5
test_output_contains("hist(z[lower.tri(z)]", incorrect_msg = "Oops! Have you plotted the lower triangle of your correlation matrix properly?")

success_msg("Well done!")
```


--- type:VideoExercise lang:r xp:50 skills:1 key:b48ce393f1
## Modern portfolio theory of Harry Markowitz


*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v2/hls-ch4_1.master.m3u8


--- type:NormalExercise lang:r xp:100 skills:1 key:c066b2d5f610d13afdb48831249d18142590def7
## Finding the mean-variance efficient portfolio  

A mean-variance efficient portfolio can be obtained as the solution of minimizing the portfolio variance under the constraint that the portfolio expected return equals a target return. A convenient R function for doing so is the function [portfolio.optim()](http://www.rdocumentation.org/packages/tseries/functions/portfolio.optim) in the R package [tseries](http://www.rdocumentation.org/packages/tseries). 
Its default implementation finds the mean-variance efficient portfolio weights under the constraint that the portfolio return equals the return on the equally-weighted portfolio. 
The only argument needed is the monthly return data on the portfolio components for which the weights need to be determined.


*** =instructions
- load the library `tseries`. 
- Create a mean-variance efficient portfolio of monthly returns using `portfolio.optim()`, called `optim`. 
- Create a vector of weights from your optimized portfolio. Portfolio weights can be found in `optim$pw`. Call this `pf_weights`.
- Assign the names to the assets using the provided code.
- Select the optimum weights from `pf_weights` that are greater than or equal to 1%, call this `optim_weights`. 
- Create a barplot of `optim_weights`.
- Print the expect portfolio return (`optim$pm`) and volatility (`optim$ps`) of the optimized portfolio. 

*** =hint
The optimimum weights can be selected from `pf_weights` using the following code: `optim_weights <- pf_weights[pf_weights >= 0.01]`

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices <- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# Load tseries


# Create an optimized portfolio of returns


# Create pf_weights


# Assign asset names


# Select optimum weights optim_weights


# Barplot of optim_weights


# Print expected portfolio return and volatility

 
```

*** =solution
```{r}
# Load tseries
library(tseries)

# Create an optimized portfolio of returns
optim <- portfolio.optim(returns)

# Create pf_weights
pf_weights<- optim$pw

# Assign asset names
names(pf_weights) <- colnames(returns)

# Select optimum weights optim_weights
optim_weights <- pf_weights[pf_weights >= 0.01]

# Barplot of optim_weights
barplot(optim_weights)

# Print expected portfolio return and volatility
optim$pm
optim$ps

```

*** =sct
```{r}
#1
test_library_function("tseries", not_called_msg = "You need to load the `tseries` package!")
test_object("optim", undefined_msg = "Remember to create your optimized portfolio!", incorrect_msg = "Be sure to supply `returns` to `portfolio.optim()`!")

#2
test_object("pf_weights", undefined_msg = "Oops! It looks like you didn't create a vector of portfolio weights.", incorrect_msg = "Make sure you select the portfolio weights from `optim`.")

#3
test_student_typed("names(pf_weights) <- colnames(returns)", not_typed_msg = "Oops! Be sure you don't change the code for the name assignmnet!")

#4
test_object("optim_weights", undefined_msg = "You need to create your optimum weights object!", incorrect_msg = "Remember that optimum weights are greater than or equal to 1%!")

#5
test_function("barplot", "x", not_called_msg = "Remember to plot your optimum weights!", incorrect_msg = "Make sure you selected the correct values for your optimum weights.")

#5
test_output_contains("optim$pm")
test_output_contains("optim$ps")

# sct code
success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1  key:2240e86100
## Affect of the return target 

This exercise will show the affect of increasing your target return on your potential risk. 

The function [portfolio.optim](http://www.rdocumentation.org/packages/tseries/functions/portfolio.optim) has arguments that allow for more general specifications. The arguments are as follows:

```
portfolio.optim(x, pm = mean(x), shorts = FALSE, reshigh = NULL)
```

The argument `pm` sets the target return, the argument `reshigh` specifies the upper constraints on the portfolio weights, and the argument `shorts` is a logical statement specifying whether negative weights are forbidden or not, by default `shorts = FALSE`. 

You will create a portfolio that is optimized for a target return that is the equivalent of the mean return from the return series `returns`. Then you will create a portfolio that has a target return that is 10% higher than the mean return series, and calculate the percent change in risk.


*** =instructions
- Create a portfolio where the target return is the mean of `returns`. Call this `pf_mean`.
- Create a portfolio where the target return is 10% greater than the mean of `returns`. Call this `pf_10plus`.
- Print the standard deviations of both portfolios. Remember that the portfolio standard deviation is stored in `$ps`. 
- Calculate the percent increase in standard deviation.

*** =hint
For your second portfolio, set `pm = 1.1 * mean(returns)`. 

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]

library(tseries)
```

*** =sample_code
```{r}
# Create portfolio with target return of average returns 


# Create portfolio with target return 10% greater than average returns


# Print the standard deviations of both portfolios



# Calculate the percent increase in standard deviation


```

*** =solution
```{r}
# Create portfolio with target return of average returns 
pf_mean <- portfolio.optim(returns, pm = mean(returns))

# Create portfolio with target return 10% greater than average returns
pf_10plus <- portfolio.optim(returns, pm = 1.1 * mean(returns))

# Print the standard deviations of both portfolios
pf_mean$ps
pf_10plus$ps

# Calculate the percent increase in standard deviation
(pf_10plus$ps - pf_mean$ps) / (pf_mean$ps)

```

*** =sct
```{r}
#1
test_object("pf_mean", undefined_msg = "Don't forget to create a portfolio where the target return is the mean return!", incorrect_msg = "Make sure you set `pm` equal to the mean of your returns.")
#2
test_object("pf_10plus", undefined_msg = "Oops! It looks like you didn't create a portfolio with a 10% greater target return.", incorrect_msg = "Make sure that `pm` is set to 10% more than your mean return.")
#3
test_output_contains("pf_mean$ps")
test_output_contains("pf_10plus$ps")

#4
test_output_contains("(pf_10plus$ps - pf_mean$ps) / (pf_mean$ps) * 100")

# sct code
success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1 key:6f3df5bc7125d675f226ddc4c69639e2cf24d23c
## Imposing weight constraints

Investors are often constrained by the maximum values allowed for the portoflio weights. This constraints can actually be an advantage. The advantage of a maximum weight constraint is that the subsequent portfolio will be less concentrated in certain assets. There is a disadvantage to this though. The disadvantage is that the same target return, may no longer be possible or will be obtained at the expense of a higher volatility. 

Finding the optimized portfolio under weight constraints is made easy with the *PerformanceAnalytics* package. The function `portfolio.optim()` allows you to set weight constraints within the `reshigh` argument. `reshigh` requires a vector of maximum weights for each asset. 

In this exercise you will create three portfolios with different maximum weight constraints. For this exercise it is important to know the output of the `portfolio.optim()` function. This function creates a list containing four components: (i) `$pw`: the portfolio weights, (ii) `$px`: the returns of the overall portfolio, (iii) `$pm`: the exepcted return portfolio, (iv) `$ps`: the standard deviation of the portfolio returns.

*** =instructions
- Create three vectors of maximum weights for each asset (column) in `returns` using the `rep()` function. The first vector will contain maximum weights of 100%, the second 10%, and the third 5%. Call these `weights1`, `weights2`, `weights3`, respectively. 
- Create an optimum portfolio with maximum weights of 100% called `optim1`.
- Create an optimum portfolio with maximum weights of 10% called `optim2`.
- Create an optimum portfolio with maximum weights of 5% called `optim3`.
- Calculate how many assets have a weight that is greater than 1% for each portfolio. Access weights by using `$pw` after the portfolio name.
- Print the volatilities of the portfolio you created. 

*** =hint
The argument `reshigh` needs to be a vector. 

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]

library(tseries)
```

*** =sample_code
```{r}
# Create vectors of maximum weights




# Create an optimum portfolio with max weights of 100%


# Create an optimum portfolio with max weights of 10%


# Create an optimum portfolio with max weights of 5%


# Calculate how many assets have a weight that is greater than 1% for each portfolio




# Print portfolio volatilites 
```

*** =solution
```{r}
# Create vectors of maximum weights
weights1 <- rep(1, ncol(returns))
weights2 <- rep(0.1, ncol(returns))
weights3 <- rep(0.05, ncol(returns))

# Create an optimum portfolio with max weights of 100%
optim1 <- portfolio.optim(returns, reshigh = weights1)

# Create an optimum portfolio with max weights of 10%
optim2 <- portfolio.optim(returns, reshigh = weights2)

# Create an optimum portfolio with max weights of 5%
optim3 <- portfolio.optim(returns, reshigh = weights3)

# Calculate how many assets have a weight that is greater than 1% for each portfolio
sum(optim1$pw > .01)
sum(optim2$pw > .01)
sum(optim3$pw > .01)

# Print portfolio volatilites 
optim1$ps
optim2$ps
optim3$ps
```

*** =sct
```{r}
#1
test_object("weights1", undefined_msg = "Be sure you create the three weights vectors!", incorrect_msg = "Make sure that this is a vector where each value is equal to 1.")
test_object("weights2", undefined_msg = "Be sure you create the three weights vectors!", incorrect_msg = "Make sure that this is a vector where each value is equal to 0.1")
test_object("weights3", undefined_msg = "Be sure you create the three weights vectors!", incorrect_msg = "Make sure that this is a vector where each value is equal to 0.05")

#2
test_function("portfolio.optim", c("x", "reshigh"), not_called_msg = "Make sure to create a portfolio where the max weights are equal to 100%!", incorrect_msg = "Did you supply the correct weights vector to `optim1`?", index = 1)

#3
test_function("portfolio.optim", c("x", "reshigh"), not_called_msg = "Make sure to create a portfolio where the max weights are equal to 10%!", incorrect_msg = "Did you supply the correct weights vector to `optim2`?", index = 2)

#4
test_function("portfolio.optim", c("x", "reshigh"), not_called_msg = "Make sure to create a portfolio where the max weights are equal to 5%!", incorrect_msg = "Did you supply the correct weights vector to `optim3`?", index = 3)

#5
test_function("sum", "...", index = 1)
test_function("sum", "...", index = 2)
test_function("sum", "...", index = 3)

#6
test_output_contains("optim1$ps")
test_output_contains("optim2$ps")
test_output_contains("optim3$ps")

# sct code
success_msg("Well done!")
```

--- type:VideoExercise lang:r xp:50 skills:1 key:461436d2ee4b426f97b3c95b6ee39836ae38b34f
## The efficient frontier

*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v2/hls-ch4_2.master.m3u8

--- type:NormalExercise lang:r xp:100 skills:1 key:2c03a87fc29fb66e35d8cdbf244b3dcf41305824
## Computing the efficient frontier using a grid of target returns

NEEDS REWORKING

As we have seen, one approach to compute the efficient frontier is to first define the grid of target returns and then find, for each target return, the portfolio that has an expected return equal to the target return at the lowest possible variance. 

But what is a reasonble grid of target returns? We will set the maximum target return to the maximum average return of the stocks. Ideally, we set the minimum target return to the return of the minimum variance portfolio. Since we don't know this minimum variance portfolio return yet, let's therefore take the largest possible grid starting with the minimum average returns of all stocks. 


*** =instructions
- Complete the code specifying the grid of 50 equally spaced return targets starting at the minimum and maximum average return 
- Run the loop computing the optimized weights and corresponding mean return and volatility
- Plot the portfolio mean against the portfolio volatility of the optimized portfolios
- Improve the efficient frontier plot by removing the inefficient portfolios offering a lower return at a higher risk compared to the minimum variance portfolio.  

*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
library(tseries)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# sample code
stockmu <- colMeans(returns)
grid <- seq( , ,length.out=50 )  
# Compute the efficient frontier
## for each solution, we save the portfolio mean,
## portfolio standard deviation and the weights
## Initialize them as an empty vector
vpm = vpsd = mweights <- c()
for( mutarget in grid ){
  out <- try(portfolio.optim(x = returns ,pm=mutarget),silent=TRUE)
  if(class(out)!="try-error"){
    vpm <- c(vpm,out$pm)
    vpsd <- c(vpsd,out$ps)
    mweights <- rbind( mweights,out$pw)
  }
}
colnames(mweights) <- colnames(returns)
# report the scatter plot of vpm agains vpsd
plot( ,  , xlab="(monthly) Volatility" , ylab="(monthly) average returns", 
      main="Minimum variance portfolios under a return target constraint",
      type="l",lwd=2)
```

*** =solution
```{r}
# solution code
stockmu <- colMeans(returns)
grid <- seq(min(stockmu),max(stockmu),length.out=50)  
# Compute the efficient frontier
## for each solution, we save the portfolio mean,
## portfolio standard deviation and the weights
## Initialize them as an empty vector
vpm = vpsd = mweights <- c()

for( mutarget in grid ){
  out <- try(portfolio.optim(x = returns ,pm=mutarget),silent=TRUE)
  if(class(out)!="try-error"){
    vpm <- c(vpm,out$pm)
    vpsd <- c(vpsd,out$ps)
    mweights <- rbind( mweights,out$pw)
  }
}
# report the scatter plot of vpm agains vpsd
plot(vpsd,vpm, xlab="(monthly) Volatility" , ylab="(monthly) average returns", 
     main="Minimum variance portfolios \n under a return target constraint",type="l",lwd=2)
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```

--- type:MultipleChoiceExercise lang:r xp:50 skills:1    key:e647c251a7
## Properties of the efficient frontier

The curve shown in the previous plot shows the solution of minimizing the variance under the constraint that the portfolio expected return equals the target return. When the target return is below the minimum variance return, the obtained portfolio is not efficient because a higher return at a lower risk can be optained by investing in the minimum variance portfolio.
The optimized portfolios often are also not realistic because they tend to invest large weights in only a few assets. A practical solution to avoid this is to impose weight constraints. 

The effect of such a weight constraint is shown in the work space, where you can see the efficient frontier plots obtained for the DJIA stocks under a maximum 100% weight constraint (black line), a maximum 10% weight constraint (red line) and a maximum 5% weight constraint (blue). 

Which of the following statements is false.  

*** =instructions
- Imposing a more strict weight constraint, leads to a shift to the right of the efficient frontier.    
- The portfolios on the dashed lines are not mean-variance efficient. 
- The observed average return of any risky portfolio is always higher than the risk-free rate. 
- None of the above.

*** =hint
Even some risky portfolios can have a lower return than a risk-free rate.

*** =pre_exercise_code
```{r}
library(xts)
library(PerformanceAnalytics)
library(tseries)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]

stockmu <- apply( X = returns , MARGIN = 2 , FUN="mean")
stocksd <- apply( X = returns , MARGIN = 2 , FUN="sd")

grid <- seq(min(stockmu),max(stockmu),length.out=50 )  
# Compute the efficient frontier
## for each solution, we save the portfolio mean,
## portfolio standard deviation and the weights
## Initialize them as an empty vector
vpm = vpsd = mweights = c()

for( mutarget in grid ){
  out <- try(portfolio.optim(x = returns,pm=mutarget,
                            reshigh = rep(1,ncol(returns)) ),silent=TRUE)
  if(class(out)!="try-error"){
    vpm <- c(vpm,out$pm)
    vpsd <- c(vpsd,out$ps)
    mweights <- rbind( mweights,out$pw)
  }
}

# assign the stock names to the column names of mweights
colnames(mweights) <- colnames(returns)


##################################################################################
# To avoid the concentration, we will impose now a max weight constraint of 30%

 
# Compute the efficient frontier
## for each solution, we save the portfolio mean,
## portfolio standard deviation and the weights
## Initialize them as an empty vector
vpm.res2 = vpsd.res2 = mweights.res2 <- c()

for( mutarget in grid ){
  out <- try(portfolio.optim(x = returns,pm=mutarget,
                  reshigh = rep(0.1,ncol(returns))),silent=TRUE)
  if(class(out)!="try-error"){
    vpm.res2 <- c(vpm.res2,out$pm)
    vpsd.res2 <- c(vpsd.res2,out$ps)
    mweights.res2 <- rbind( mweights.res2,out$pw)
  }
}
# assign the stock names to the column names of mweights
colnames(mweights.res2) <- colnames(returns)
 
##################################################################################
# To avoid the concentration, we will impose now a max weight constraint of 5%


 
# Compute the efficient frontier
## for each solution, we save the portfolio mean,
## portfolio standard deviation and the weights
## Initialize them as an empty vector
vpm.res = vpsd.res = mweights.res <- c()

for( mutarget in grid ){
  out = try(portfolio.optim(x = returns,pm=mutarget,
                  reshigh = rep(0.05,ncol(returns))),silent=TRUE)
  if(class(out)!="try-error"){
    vpm.res <- c(vpm.res,out$pm)
    vpsd.res <- c(vpsd.res,out$ps)
    mweights.res <- rbind( mweights.res,out$pw)
  }
}
# assign the stock names to the column names of mweights
colnames(mweights.res) = colnames(returns)


# 
plot(stocksd,stockmu,col="gray" , xlab="Standard deviation (monthly)", ylab="Average return (monthly",
     xlim=c(0.02,0.15), ylim=c(min(stockmu),max(stockmu)))
text( stocksd ,  stockmu ,  labels=colnames(returns), cex= 0.7)
# all portfolios offering less return than the minimum variance portfolio should be excluded
minvarpm <- vpm[vpsd==min(vpsd)]
minvarpm.res <- vpm.res[vpsd.res==min(vpsd.res)]
minvarpm.res2 <- vpm.res2[vpsd.res2==min(vpsd.res2)]
lines(vpsd,vpm,col="black",lwd=1,lty=3)
lines(vpsd.res2,vpm.res2,col="red",lwd=1,lty=3)
lines(vpsd.res,vpm.res,col="blue",lwd=1,lty=3)
lines(vpsd[vpm>=minvarpm],vpm[vpm>=minvarpm],col="black",lwd=2)
lines(vpsd.res2[vpm.res2>=minvarpm.res2],vpm.res2[vpm.res2>=minvarpm.res2],col="red",lwd=2)
lines(vpsd.res[vpm.res>=minvarpm.res],vpm.res[vpm.res>=minvarpm.res],col="blue",lwd=2)

```

*** =sct
```{r}
test_mc(3) 
```


--- type:NormalExercise lang:r xp:100 skills:1   key:897a83541a
## The minimum variance and maximum Sharpe ratio portfolio

In the previous exercises you computed the efficient fronteir using a grid of target returns. The output of your calculation of the efficient fronteir was a series of two vectors, `vpm` (vector of portfolio means), and `vpsd` (vector of standard deviations, or volatilities), and a matrix of weights called `mweights`. You will use these outputs to identify the portfolios with the least volatility, and the greatest sharpe ratio, and then plot them.

*** =instructions
- Create `weights_minvar` as the rows in `mweights` equivalent to the minimum standard deviation in `vpsd`. 
- Calculate the sharpe ratio of portfolio returns where the risk free rate is *0.75%*. Call this `vsr`.
- Create `weights_max_sr` as the rows in `mweights` equivalent to the maximum sharpe ratio in `vsr`.
- Create a barplot of the weights that are greater than 1% in the `weights_minvar` portfolio.
- Create a barplot of the weights that are greater than 1% in the `weights_max_sr` portfolio.

*** =hint
Use a logical in the selection bracket when selecting rows from `mweights`. For example `mweights[row == value, ]`.

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
library(tseries)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
stockmu <- colMeans(returns)

grid = seq(min(stockmu),max(stockmu),length.out=50 )  
# Compute the efficient frontier
## for each solution, we save the portfolio mean,
## portfolio standard deviation and the weights
## Initialize them as an empty vector
vpm = vpsd = mweights = c()

for( mutarget in grid ){
  out <- try(portfolio.optim(x = returns ,pm=mutarget),silent=TRUE)
  if(class(out)!="try-error"){
    vpm <-  c(vpm,out$pm)
    vpsd <- c(vpsd,out$ps)
    mweights <- rbind( mweights,out$pw)
  }
}
colnames(mweights) <- colnames(returns)
```

*** =sample_code
```{r}
# Create weights_minvar as the portfolio with the least risk


# Calculate the sharpe ratio


# Create weights_max_sr as the portfolio with the maximum sharpe ratio


# Create barplot of weights_minvar and weights_max_sr
par(mfrow = c(2, 1), mar = c(3, 2, 2, 1))

 
 
```

*** =solution
```{r}
# Create weights_minvar as the portfolio with the least risk
weights_minvar <- mweights[vpsd == min(vpsd),]

# Calculate the sharpe ratio
vsr <- (vpm - 0.0075) / vpsd

# Create weights_max_sr as the portfolio with the maximum sharpe ratio
weights_max_sr <- mweights[vsr == max(vsr), ]

# Create barplot of weights_minvar and weights_max_sr
par(mfrow = c(2, 1), mar = c(3, 2, 2, 1))
barplot(weights_minvar[weights_minvar > 0.01])
barplot(weights_max_sr[weights_max_sr > 0.01]) 

```

*** =sct
```{r}
test_object("weights_minvar", undefined_msg = "Make sure you select the portfolio with the minimum variance!")

test_object("vsr", undefined_msg = "Oops! Don't forget to create a vector of sharpe ratios.")

test_object("weights_max_sr", undefined_msg = "It looks like you select the portfolio with the maximum sharpe ratio!")

test_function("par", c("mfrow", "mar"))
test_function("barplot", "height", index = 1)
test_function("barplot", "height", index = 2)
# sct code
success_msg("Well done!")
```



--- type:VideoExercise lang:r xp:50 skills:1 key:ca405aabc3c21c142aaae409da6302b77b5210ef
## In-sample versus out-of-sample evaluation


*** =video_link
//player.vimeo.com/video/108225030

*** =video_hls
//videos.datacamp.com/transcoded/985_portfolio_analysis/v2/hls-ch4_3.master.m3u8

--- type:NormalExercise lang:r xp:100 skills:1 key:69f72e3a22916ec2ef924a7f212d354f28022366
## Split-sample evaluation

In chapter 2 you used the function [window()](http://www.rdocumentation.org/packages/stats/functions/window) to subset your returns for graphical purposes. In this exercise you will use the `window()` to create two samples: an estimation sample and an evaluation sample. This exercise will illustrate how portfolio weights can differ when changing the estimation window.

To remind you, the function [window()](http://www.rdocumentation.org/packages/stats/functions/window) has argument of `x`, `start`, and `end`. Where `start` and `end` are in the format `"YYYY-MM-DD"`.

The object `returns` is loaded in your workspace. 

*** =instructions
- Create the sample `returns_estim` by subsetting `returns`, where the sample begins on January 1st, 1991, and ends of December 31st, 2003.
- Create the sample `returns_eval` by subsetting `returns`, where the sample begins on the first day of 2004, and ends on the last day of 2015.
- Create a vector of maximum weights equal to 10%, with a length as the number of columns there are in `returns` called `max_weights`.
- Create a portfolio with the estimation sample called `pf_estim`, where the maximum weight (`reshigh`) is set to `max_weights`.
- Create a portfolio with the evaluation sample called `pf_eval`, where the maximum weight (`reshigh`) is set to `max_weights`.
- Create a scatter plot of the estimation portfolio weights versus the evaluation portfolio weights. Note that if portfolio weights are identical, they should be on the 45 degree line.

*** =hint
You can use the `rep()` function to create your `max_weights` vector. In addition you can access the portfolio weights using `$pw` followed by the portfolio name.

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
library(tseries)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")
prices<- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]
```

*** =sample_code
```{r}
# Create returns_estim 


# Create returns_eval


# Create vector of max weights


# Create portfolio with estimation sample 


# Create portfolio with evaluation sample


# Create a scatter plot
plot()
abline(h = 0, b = 1, lty = 3)
```

*** =solution
```{r}
# Create returns_estim 
returns_estim <- window(returns, start = "1991-01-01", end = "2003-12-31")

# Create returns_eval
returns_eval <- window(returns, start ="2004-01-01", end = "2015-12-31")

# Create vector of max_weights
max_weights <- rep(0.1, ncol(returns))

# Create portfolio with estimation sample 
pf_estim <- portfolio.optim(returns_estim, reshigh = max_weights)

# Create portfolio with evaluation sample
pf_eval <- portfolio.optim(returns_eval, reshigh = max_weights)

# Create a scatter plot
plot(pf_estim$pw, pf_eval$pw)
abline(h = 0, b = 1, lty = 3)
```

*** =sct
```{r}
#1
test_object("returns_estim", undefined_msg = "Oops! You need to make your estimation window sample!")
#2
test_object("returns_eval", undefined_msg = "Looks like you need to make your evaluation window sample!")
#3
test_object("max_weights", undefined_msg = "Don't forget to create a vector of maximum weights!")
#4
test_object("pf_estim", undefined_msg = "Oh no! You forgot to create a portfolio using your estimation sample!")
#5
test_object("pf_eval", undefined_msg = "Oopsies! You need to create a portfolio using your evaluation sample.")

#6
test_output_contains("plot(pf_estim$pw, pf_eval$pw)")
test_output_contains("abline(h = 0, b = 1, lty =3)")
# sct code
success_msg("Well done!")
```

--- type:NormalExercise lang:r xp:100 skills:1 key:6d3bdc717d87317d8c4ccf468836039b35f78440
## Out of sample performance evaluation

This example will illustrate how your returns can change based on the weighting created by an optimized portfolio. You will use the two portfolios you created in the previous exercise (`pf_estim` and `pf_eval`).

How severe is the optimality loss? Let's compare on the out-of-sample period the mean and variance on the optimized portfolio weights using the estimation sample and the out-of-sample evaluation data. 

*** =instructions
- Use the function `table.AnnualizedReturns()` on `pf_estim`.
- Use the function `table.AnnualizedReturns()` on `pf_eval`.
- Compare the return, risk, and sharpe ratio of these portfolios. The results from the `pf_eval` are what you may expect in a real performance.

*** =hint
The only argument you need to provide is the portfolio return object name.

*** =pre_exercise_code
```{r}
# pec
library(xts)
library(PerformanceAnalytics)
library(tseries)
library(utils)
download.file("http://s3.amazonaws.com/assets.datacamp.com/course/portfolio-analysis/prices.rds", destfile="prices.rds")
# load("prices.Rdata")

prices <- readRDS("prices.rds") 
returns <- Return.calculate(prices, method="simple")
returns <- returns[(-1),]

# Splitting return data in sample for estimation and out of sample evaluation 
returns.estim <- window(returns, start = "1991-01-01", end = "2003-12-31")
returns.oos <- window(returns, start ="2004-01-01", end = "2015-12-31")
# optimize portfolios
weights.estim <- portfolio.optim(x = returns.estim , reshigh = rep(0.1,ncol(returns.estim)))$pw
weights.oos <- portfolio.optim(x = returns.oos ,reshigh = rep(0.1,ncol(returns.estim)))$pw
returns_estim <- window(returns, start = "1991-01-01", end = "2003-12-31")




# Create returns_eval
returns_eval <- window(returns, start = "2004-01-01", end = "2015-12-31")

# Create vector of max_weights
max_weights <- rep(0.1, ncol(returns))

# Create portfolio with estimation sample 
pf_estim <- portfolio.optim(returns_estim, reshigh = max_weights)

# Create portfolio with evaluation sample
pf_eval <- portfolio.optim(returns_eval, reshigh = max_weights)

```

*** =sample_code
```{r}
# Print a table for your estimation portfolio


# Print a table for your evaluation portfolio
 
```

*** =solution
```{r}
# Print a table for your estimation portfolio
table.AnnualizedReturns(pf_estim)

# Print a table for your evaluation portfolio
table.AnnualizedReturns(pf_eval)
```

*** =sct
```{r}
# sct code
test_function("table.AnnualizedReturns","R", index = 1)
test_function("table.AnnualizedReturns","R", index = 2)
success_msg("Good job!")
```

 
--- type:NormalExercise lang:r xp:100 skills:1   key:9d55676210
## It ain't over
 
You made it! This journey showed you how to compute returns, analyze portfolio performance and optimize portfolios. These are important skills, since whenever you hold or manage more than one asset, you have a portfolio to consider. 

It is now time to compound and get extra return by exploring other useful R packages for portfolio analysis like *PortfolioAnalytics*. Instead of optimizing the portfolio by minimizing the variance under a return targetg constraint, this package allows you optimize virtually all objective functions under all possible constraints. Even if the solution to the problem is not feasible, it will give you the best possible solution using heuristics such as differential evolution in the R package *DEoptim*. Since I have been involved in both packages, this last exercise is an act of shameless selfpromotion. 

Have fun! 

*** =instructions
- Load the package PortfolioAnalytics and explore the functionality of this package by entering the instruction `?PortfolioAnalytics`. 
- Read my article on portfolio optimization with DEoptim. 
*** =hint
hint comes here

*** =pre_exercise_code
```{r}
# pec
library(Biobase)
uri <- "https://journal.r-project.org/archive/2011-1/RJournal_2011-1_Ardia~et~al.pdf"
download.file(uri,"deoptim.pdf",method="internal",mode="wb")

```

*** =sample_code
```{r}
# load and explore the package PortfolioAnalytics

# happy reading!
openPDF("deoptim.pdf")
```

*** =solution
```{r}
# solution code
```

*** =sct
```{r}
# sct code
success_msg("Well done!")
```



